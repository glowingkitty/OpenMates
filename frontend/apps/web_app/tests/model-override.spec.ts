/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-require-imports */
export {};

const { test, expect } = require('@playwright/test');

const consoleLogs: string[] = [];
const networkActivities: string[] = [];

test.beforeEach(async () => {
	consoleLogs.length = 0;
	networkActivities.length = 0;
});

// eslint-disable-next-line no-empty-pattern
test.afterEach(async ({}, testInfo: any) => {
	if (testInfo.status !== 'passed') {
		console.log('\n--- DEBUG INFO ON FAILURE ---');
		console.log('\n[RECENT CONSOLE LOGS]');
		consoleLogs.slice(-30).forEach((log) => console.log(log));

		console.log('\n[RECENT NETWORK ACTIVITIES]');
		networkActivities.slice(-30).forEach((activity) => console.log(activity));
		console.log('\n--- END DEBUG INFO ---\n');
	}
});

const {
	createSignupLogger,
	archiveExistingScreenshots,
	createStepScreenshotter,
	generateTotp
} = require('./signup-flow-helpers');

/**
 * Model override test via MentionDropdown autocomplete.
 *
 * Tests the @mention autocomplete flow for selecting AI models:
 * 1. Type "@" in message input to trigger MentionDropdown
 * 2. Type partial model name to filter results
 * 3. Verify model appears in dropdown
 * 4. Press Tab to autocomplete selection
 * 5. Type question and send message
 * 6. Verify response shows correct model in "generated by" text
 *
 * Based on: docs/architecture/ai_model_selection.md
 * Component: frontend/packages/ui/src/components/enter_message/MentionDropdown.svelte
 *
 * REQUIRED ENV VARS:
 * - OPENMATES_TEST_ACCOUNT_EMAIL: Email of an existing test account.
 * - OPENMATES_TEST_ACCOUNT_PASSWORD: Password for the test account.
 * - OPENMATES_TEST_ACCOUNT_OTP_KEY: 2FA OTP secret (base32) for the test account.
 * - PLAYWRIGHT_TEST_BASE_URL: Base URL for the deployed web app under test.
 */

const TEST_EMAIL = process.env.OPENMATES_TEST_ACCOUNT_EMAIL;
const TEST_PASSWORD = process.env.OPENMATES_TEST_ACCOUNT_PASSWORD;
const TEST_OTP_KEY = process.env.OPENMATES_TEST_ACCOUNT_OTP_KEY;

/**
 * Helper function to log in to the test account.
 */
async function loginToTestAccount(
	page: any,
	logCheckpoint: (message: string, metadata?: Record<string, unknown>) => void,
	takeStepScreenshot: (page: any, label: string) => Promise<void>
): Promise<void> {
	await page.goto('/');
	await takeStepScreenshot(page, 'home');

	const headerLoginButton = page.getByRole('button', {
		name: /login.*sign up|sign up/i
	});
	await expect(headerLoginButton).toBeVisible();
	await headerLoginButton.click();
	await takeStepScreenshot(page, 'login-dialog');

	const emailInput = page.locator('input[name="username"][type="email"]');
	await expect(emailInput).toBeVisible();
	await emailInput.fill(TEST_EMAIL);
	await page.getByRole('button', { name: /continue/i }).click();
	logCheckpoint('Entered email and clicked continue.');

	// Wait for password field with longer timeout - login flow transition may take time
	const passwordInput = page.locator('input[type="password"]');
	await expect(passwordInput).toBeVisible({ timeout: 15000 });
	await passwordInput.fill(TEST_PASSWORD);
	await takeStepScreenshot(page, 'password-entered');

	// Wait for OTP input with longer timeout
	const otpInput = page.locator('input[autocomplete="one-time-code"]');
	await expect(otpInput).toBeVisible({ timeout: 15000 });

	// Generate fresh OTP right before submitting to avoid expiration issues
	const otpCode = generateTotp(TEST_OTP_KEY);
	await otpInput.fill(otpCode);
	logCheckpoint('Generated and entered OTP.');
	await takeStepScreenshot(page, 'otp-entered');

	const submitLoginButton = page.locator('button[type="submit"]', { hasText: /log in|login/i });
	await expect(submitLoginButton).toBeVisible();
	await submitLoginButton.click();
	logCheckpoint('Submitted login form.');

	// Wait for redirect to chat - increase timeout since auth can take a moment
	await page.waitForURL(/chat/, { timeout: 30000 });
	logCheckpoint('Logged in successfully, redirected to chat.');

	// Wait for chat interface to fully load
	logCheckpoint('Waiting for chat interface to load...');
	await page.waitForTimeout(5000);

	// Verify we're in the chat - the message editor should be visible
	const messageEditor = page.locator('.editor-content.prose');
	await expect(messageEditor).toBeVisible({ timeout: 15000 });
	logCheckpoint('Chat interface loaded - message editor visible.');
}

/**
 * Helper function to start a new chat session.
 * Clicks the new chat button if visible to ensure a fresh chat state.
 * Based on the pattern in chat-flow.spec.ts.
 */
async function startNewChat(
	page: any,
	logCheckpoint: (message: string, metadata?: Record<string, unknown>) => void
): Promise<void> {
	// Wait a moment for UI to stabilize after any previous operations
	await page.waitForTimeout(1000);

	// Check if "New Chat" button is visible and click it to ensure we're in a fresh chat
	// The button may not be visible if we're already in a fresh chat state
	const newChatButton = page.locator('.icon_create');
	if (await newChatButton.isVisible()) {
		logCheckpoint('New Chat button visible, clicking it to start a fresh chat.');
		await newChatButton.click();
		await page.waitForTimeout(2000); // Wait for new chat to initialize
	} else {
		logCheckpoint('New Chat button not visible - already in a fresh chat state.');
	}

	// Log assistant message count for debugging
	const assistantMessages = page.locator('.message-wrapper.assistant');
	const messageCount = await assistantMessages.count();
	logCheckpoint(`Current assistant message count: ${messageCount}`);
}

/**
 * Helper function to select a model via @ mention autocomplete.
 * Types "@" followed by the model search term, waits for dropdown,
 * verifies the model appears, and presses Tab to autocomplete.
 *
 * @param page - Playwright page object
 * @param modelSearchTerm - Partial model name to search (e.g., "qwen3" or "gpt-5.2")
 * @param expectedModelDisplayName - Expected model name in dropdown (for verification)
 * @param logCheckpoint - Logging function
 * @param takeStepScreenshot - Screenshot function
 * @param stepLabel - Label for screenshots
 */
async function selectModelViaMentionDropdown(
	page: any,
	modelSearchTerm: string,
	expectedModelDisplayName: string,
	logCheckpoint: (message: string, metadata?: Record<string, unknown>) => void,
	takeStepScreenshot: (page: any, label: string) => Promise<void>,
	stepLabel: string
): Promise<void> {
	const messageEditor = page.locator('.editor-content.prose');
	await expect(messageEditor).toBeVisible();
	await messageEditor.click();
	logCheckpoint('Clicked on message editor.');

	// Type "@" to trigger the mention dropdown
	await page.keyboard.type('@');
	logCheckpoint('Typed "@" to trigger mention dropdown.');
	await page.waitForTimeout(500);

	// Type the model search term to filter
	await page.keyboard.type(modelSearchTerm);
	logCheckpoint(`Typed model search term: "${modelSearchTerm}"`);
	await page.waitForTimeout(500);

	// Wait for the mention dropdown to appear with increased timeout
	const mentionDropdown = page.locator('.mention-dropdown');
	await expect(mentionDropdown).toBeVisible({ timeout: 10000 });
	logCheckpoint('Mention dropdown is visible.');
	await takeStepScreenshot(page, `${stepLabel}-dropdown-visible`);

	// Verify the expected model appears in the dropdown results
	// The model name is shown in .result-name within .mention-result
	const modelResult = mentionDropdown.locator('.mention-result .result-name', {
		hasText: new RegExp(expectedModelDisplayName, 'i')
	});

	await expect(modelResult).toBeVisible({ timeout: 10000 });
	logCheckpoint(`Model "${expectedModelDisplayName}" found in dropdown.`);
	await takeStepScreenshot(page, `${stepLabel}-model-in-dropdown`);

	// Press Tab to autocomplete the selection
	// According to MentionDropdown.svelte, Tab key selects the current result
	await page.keyboard.press('Tab');
	logCheckpoint('Pressed Tab to autocomplete model selection.');
	await page.waitForTimeout(500);

	// Verify dropdown is closed after selection
	await expect(mentionDropdown).not.toBeVisible({ timeout: 3000 });
	logCheckpoint('Mention dropdown closed after selection.');
	await takeStepScreenshot(page, `${stepLabel}-model-selected`);

	// Debug: Log what was actually typed/inserted into the editor
	const editorAfterSelection = page.locator('.editor-content.prose');
	const editorContent = await editorAfterSelection.textContent();
	logCheckpoint(`Editor content after model selection: "${editorContent}"`);
}

/**
 * Helper function to type a question and send the message.
 * Assumes the model has already been selected via @ mention.
 */
async function typeQuestionAndSend(
	page: any,
	question: string,
	logCheckpoint: (message: string, metadata?: Record<string, unknown>) => void,
	takeStepScreenshot: (page: any, label: string) => Promise<void>,
	stepLabel: string
): Promise<void> {
	// Type a space after the autocompleted model, then the question
	await page.keyboard.type(' ' + question);
	logCheckpoint(`Typed question: "${question}"`);
	await takeStepScreenshot(page, `${stepLabel}-question-typed`);

	// Click send button
	const sendButton = page.locator('.send-button');
	await expect(sendButton).toBeEnabled();
	await sendButton.click();
	logCheckpoint('Clicked send button.');
	await takeStepScreenshot(page, `${stepLabel}-message-sent`);

	// Wait for Chat ID in URL (if first message)
	try {
		await expect(page).toHaveURL(/chat-id=[a-zA-Z0-9-]+/, { timeout: 15000 });
	} catch {
		// URL already has chat-id, continue
	}
}

/**
 * Helper function to wait for assistant response and verify the model used.
 * Checks the "generated by" text under the assistant message.
 *
 * @returns The assistant response text content
 */
async function waitForResponseAndVerifyModel(
	page: any,
	expectedModelPattern: RegExp,
	logCheckpoint: (message: string, metadata?: Record<string, unknown>) => void,
	takeStepScreenshot: (page: any, label: string) => Promise<void>,
	stepLabel: string
): Promise<string> {
	logCheckpoint('Waiting for assistant response...');

	// Count existing assistant messages before waiting for new one
	const initialCount = await page.locator('.message-wrapper.assistant').count();
	logCheckpoint(`Initial assistant message count: ${initialCount}`);

	// Wait for a NEW assistant message to appear (count should increase)
	await expect(async () => {
		const currentCount = await page.locator('.message-wrapper.assistant').count();
		expect(currentCount).toBeGreaterThan(initialCount);
	}).toPass({ timeout: 60000 });

	// Get the last (newest) assistant message
	const assistantMessage = page.locator('.message-wrapper.assistant').last();
	await expect(assistantMessage).toBeVisible({ timeout: 10000 });

	// Wait for streaming to complete - the "generated by" text appears after streaming ends
	// The generated-by element is INSIDE the message wrapper, so we need to scope it
	const generatedByElement = assistantMessage.locator('.generated-by-container .generated-by');
	await expect(generatedByElement).toBeVisible({ timeout: 90000 });
	logCheckpoint('Response complete - generated-by element visible.');
	await takeStepScreenshot(page, `${stepLabel}-response-complete`);

	// Get the model name from the generated-by text
	const generatedByText = await generatedByElement.textContent();
	logCheckpoint(`Generated by text: "${generatedByText}"`);

	// Verify the model name matches expected pattern
	expect(generatedByText).toMatch(expectedModelPattern);
	logCheckpoint(`Verified model matches pattern: ${expectedModelPattern}`);

	// Get the full response text
	const responseText = await assistantMessage.textContent();
	return responseText || '';
}

/**
 * Helper function to delete the active chat.
 * Based on the working pattern from chat-flow.spec.ts.
 *
 * Key insight: The sidebar's .active class may not update immediately after creating a new chat.
 * We need to find the chat by its chat-id from the URL, not rely on .active class.
 */
async function deleteActiveChat(
	page: any,
	logCheckpoint: (message: string, metadata?: Record<string, unknown>) => void,
	takeStepScreenshot: (page: any, label: string) => Promise<void>,
	stepLabel: string
): Promise<void> {
	logCheckpoint('Attempting to delete the chat...');

	// Get the current chat ID from the URL
	const currentUrl = page.url();
	const chatIdMatch = currentUrl.match(/chat-id=([a-zA-Z0-9-]+)/);
	const currentChatId = chatIdMatch ? chatIdMatch[1] : null;
	logCheckpoint(`Current chat ID from URL: ${currentChatId}`);

	// Ensure sidebar is open (if on mobile/narrow screen)
	const sidebarToggle = page.locator('.sidebar-toggle-button');
	if (await sidebarToggle.isVisible()) {
		await sidebarToggle.click();
		await page.waitForTimeout(500);
	}

	// Wait for sidebar to be fully loaded
	await page.waitForTimeout(1000);

	// Debug: Log all chat items in sidebar
	const allChatItems = page.locator('.chat-item-wrapper');
	const chatItemCount = await allChatItems.count();
	logCheckpoint(`Found ${chatItemCount} chat items in sidebar.`);

	// Strategy: First try to find the chat by its data attribute or link href
	// If that fails, fall back to the .active class
	let targetChatItem;

	if (currentChatId) {
		// Try to find the chat item that links to this chat ID
		// The chat item should have an onclick or be associated with this chat
		// Look for a link or button that contains the chat-id
		const chatItemByHref = page.locator(`a[href*="chat-id=${currentChatId}"]`).first();
		const chatItemByDataId = page.locator(`[data-chat-id="${currentChatId}"]`).first();

		if (await chatItemByHref.isVisible({ timeout: 2000 }).catch(() => false)) {
			// Find the parent chat-item-wrapper
			targetChatItem = chatItemByHref.locator(
				'xpath=ancestor::div[contains(@class, "chat-item-wrapper")]'
			);
			logCheckpoint('Found chat item by href.');
		} else if (await chatItemByDataId.isVisible({ timeout: 2000 }).catch(() => false)) {
			targetChatItem = chatItemByDataId;
			logCheckpoint('Found chat item by data-chat-id.');
		}
	}

	// Fallback to .active class if we couldn't find by ID
	if (!targetChatItem || !(await targetChatItem.isVisible({ timeout: 1000 }).catch(() => false))) {
		logCheckpoint('Falling back to .active class selector.');
		targetChatItem = page.locator('.chat-item-wrapper.active');
	}

	// Wait for the target chat item to be visible
	await expect(targetChatItem).toBeVisible({ timeout: 10000 });
	logCheckpoint('Target chat item is visible.');

	// Debug: Get the chat title if available
	try {
		const chatTitle = await targetChatItem.locator('.chat-title').textContent();
		logCheckpoint(`Target chat title: "${chatTitle}"`);
	} catch {
		logCheckpoint('Could not get target chat title.');
	}

	// Right-click to open context menu
	await targetChatItem.click({ button: 'right' });
	await takeStepScreenshot(page, `${stepLabel}-context-menu-open`);
	logCheckpoint('Opened chat context menu via right-click.');

	// Wait for context menu to appear and be stable
	await page.waitForTimeout(300);

	// Click delete button (first time to enter confirm mode)
	const deleteButton = page.locator('.menu-item.delete');
	await expect(deleteButton).toBeVisible({ timeout: 5000 });
	await deleteButton.click();
	await takeStepScreenshot(page, `${stepLabel}-delete-confirm-mode`);
	logCheckpoint('Clicked delete, now in confirm mode.');

	// Click delete button again to confirm
	await deleteButton.click();
	logCheckpoint('Confirmed chat deletion.');

	// Verify chat is removed (should redirect to home or another chat)
	await expect(targetChatItem).not.toBeVisible({ timeout: 10000 });
	await takeStepScreenshot(page, `${stepLabel}-chat-deleted`);
	logCheckpoint('Verified chat deletion successfully.');
}

/**
 * Test: Select Qwen model via @ mention dropdown and verify it's used.
 *
 * Flow:
 * 1. Type "@qwen" in message input
 * 2. Verify "Qwen 3 256b" appears in MentionDropdown
 * 3. Press Tab to autocomplete
 * 4. Type "Capital city of Germany? short answer please."
 * 5. Send message
 * 6. Verify response shows "Qwen" in generated-by text
 */
test('select qwen model via @ mention dropdown', async ({ page }: { page: any }) => {
	page.on('console', (msg: any) => {
		const timestamp = new Date().toISOString();
		consoleLogs.push(`[${timestamp}] [${msg.type()}] ${msg.text()}`);
	});

	page.on('request', (request: any) => {
		const timestamp = new Date().toISOString();
		networkActivities.push(`[${timestamp}] >> ${request.method()} ${request.url()}`);
	});

	page.on('response', (response: any) => {
		const timestamp = new Date().toISOString();
		networkActivities.push(`[${timestamp}] << ${response.status()} ${response.url()}`);
	});

	test.slow();
	test.setTimeout(180000);

	const logCheckpoint = createSignupLogger('MODEL_MENTION_QWEN');
	const takeStepScreenshot = createStepScreenshotter(logCheckpoint, { filenamePrefix: 'qwen' });

	test.skip(!TEST_EMAIL, 'OPENMATES_TEST_ACCOUNT_EMAIL is required.');
	test.skip(!TEST_PASSWORD, 'OPENMATES_TEST_ACCOUNT_PASSWORD is required.');
	test.skip(!TEST_OTP_KEY, 'OPENMATES_TEST_ACCOUNT_OTP_KEY is required.');

	await archiveExistingScreenshots(logCheckpoint);

	logCheckpoint('Starting Qwen model mention test.', { email: TEST_EMAIL });

	// Login
	await loginToTestAccount(page, logCheckpoint, takeStepScreenshot);

	// Start a new chat
	await startNewChat(page, logCheckpoint);

	// Select Qwen model via @ mention dropdown
	// Search term "qwen" should find "Qwen 3 256b" in the dropdown
	await selectModelViaMentionDropdown(
		page,
		'qwen',
		'Qwen',
		logCheckpoint,
		takeStepScreenshot,
		'qwen'
	);

	// Type the question and send
	await typeQuestionAndSend(
		page,
		'Capital city of Germany? short answer please.',
		logCheckpoint,
		takeStepScreenshot,
		'qwen'
	);

	// Wait for response and verify Qwen model was used
	// The generated-by text should contain "Qwen" (case-insensitive)
	const response = await waitForResponseAndVerifyModel(
		page,
		/qwen/i,
		logCheckpoint,
		takeStepScreenshot,
		'qwen'
	);

	// Verify the response contains the expected answer
	expect(response.toLowerCase()).toContain('berlin');
	logCheckpoint('Verified response contains "Berlin".');

	// Cleanup
	await deleteActiveChat(page, logCheckpoint, takeStepScreenshot, 'qwen-cleanup');

	logCheckpoint('Qwen model mention test completed successfully.');
});

/**
 * Test: Select GPT-5.2 model via @ mention dropdown and verify it's used.
 *
 * Flow:
 * 1. Type "@gpt-5.2" in message input
 * 2. Verify "GPT-5.2" appears in MentionDropdown
 * 3. Press Tab to autocomplete
 * 4. Type "Capital city of Germany? short answer please."
 * 5. Send message
 * 6. Verify response shows "GPT-5.2" in generated-by text
 */
test('select gpt-5.2 model via @ mention dropdown', async ({ page }: { page: any }) => {
	page.on('console', (msg: any) => {
		const timestamp = new Date().toISOString();
		consoleLogs.push(`[${timestamp}] [${msg.type()}] ${msg.text()}`);
	});

	page.on('request', (request: any) => {
		const timestamp = new Date().toISOString();
		networkActivities.push(`[${timestamp}] >> ${request.method()} ${request.url()}`);
	});

	page.on('response', (response: any) => {
		const timestamp = new Date().toISOString();
		networkActivities.push(`[${timestamp}] << ${response.status()} ${response.url()}`);
	});

	test.slow();
	test.setTimeout(180000);

	const logCheckpoint = createSignupLogger('MODEL_MENTION_GPT');
	const takeStepScreenshot = createStepScreenshotter(logCheckpoint, { filenamePrefix: 'gpt' });

	test.skip(!TEST_EMAIL, 'OPENMATES_TEST_ACCOUNT_EMAIL is required.');
	test.skip(!TEST_PASSWORD, 'OPENMATES_TEST_ACCOUNT_PASSWORD is required.');
	test.skip(!TEST_OTP_KEY, 'OPENMATES_TEST_ACCOUNT_OTP_KEY is required.');

	await archiveExistingScreenshots(logCheckpoint);

	logCheckpoint('Starting GPT-5.2 model mention test.', { email: TEST_EMAIL });

	// Login
	await loginToTestAccount(page, logCheckpoint, takeStepScreenshot);

	// Start a new chat
	await startNewChat(page, logCheckpoint);

	// Select GPT-5.2 via @ mention dropdown
	// Search term "gpt-5.2" should find "GPT-5.2" in the dropdown
	await selectModelViaMentionDropdown(
		page,
		'gpt-5.2',
		'GPT-5.2',
		logCheckpoint,
		takeStepScreenshot,
		'gpt'
	);

	// Type the question and send
	await typeQuestionAndSend(
		page,
		'Capital city of Germany? short answer please.',
		logCheckpoint,
		takeStepScreenshot,
		'gpt'
	);

	// Wait for response and verify GPT-5.2 model was used
	// The generated-by text should contain "GPT-5.2" (case-insensitive)
	const response = await waitForResponseAndVerifyModel(
		page,
		/gpt-?5\.?2/i,
		logCheckpoint,
		takeStepScreenshot,
		'gpt'
	);

	// Verify the response contains the expected answer
	expect(response.toLowerCase()).toContain('berlin');
	logCheckpoint('Verified response contains "Berlin".');

	// Cleanup
	await deleteActiveChat(page, logCheckpoint, takeStepScreenshot, 'gpt-cleanup');

	logCheckpoint('GPT-5.2 model mention test completed successfully.');
});

/**
 * Test: Switch between models in the same session using @ mention dropdown.
 *
 * Flow:
 * 1. Login once
 * 2. Test Qwen: Select via @qwen, send question, verify response
 * 3. Delete chat
 * 4. Test GPT-5.2: Select via @gpt-5.2, send question, verify response
 * 5. Delete chat
 */
test('switch between qwen and gpt-5.2 via @ mention dropdown', async ({ page }: { page: any }) => {
	page.on('console', (msg: any) => {
		const timestamp = new Date().toISOString();
		consoleLogs.push(`[${timestamp}] [${msg.type()}] ${msg.text()}`);
	});

	page.on('request', (request: any) => {
		const timestamp = new Date().toISOString();
		networkActivities.push(`[${timestamp}] >> ${request.method()} ${request.url()}`);
	});

	page.on('response', (response: any) => {
		const timestamp = new Date().toISOString();
		networkActivities.push(`[${timestamp}] << ${response.status()} ${response.url()}`);
	});

	test.slow();
	test.setTimeout(300000);

	const logCheckpoint = createSignupLogger('MODEL_MENTION_SWITCH');
	const takeStepScreenshot = createStepScreenshotter(logCheckpoint, { filenamePrefix: 'switch' });

	test.skip(!TEST_EMAIL, 'OPENMATES_TEST_ACCOUNT_EMAIL is required.');
	test.skip(!TEST_PASSWORD, 'OPENMATES_TEST_ACCOUNT_PASSWORD is required.');
	test.skip(!TEST_OTP_KEY, 'OPENMATES_TEST_ACCOUNT_OTP_KEY is required.');

	await archiveExistingScreenshots(logCheckpoint);

	logCheckpoint('Starting model switching test.', { email: TEST_EMAIL });

	// Login once
	await loginToTestAccount(page, logCheckpoint, takeStepScreenshot);

	// --- Test 1: Qwen ---
	logCheckpoint('--- Testing Qwen model via @ mention ---');
	await startNewChat(page, logCheckpoint);

	await selectModelViaMentionDropdown(
		page,
		'qwen',
		'Qwen',
		logCheckpoint,
		takeStepScreenshot,
		'switch-qwen'
	);

	await typeQuestionAndSend(
		page,
		'What is 3 + 3? Answer with just the number.',
		logCheckpoint,
		takeStepScreenshot,
		'switch-qwen'
	);

	const qwenResponse = await waitForResponseAndVerifyModel(
		page,
		/qwen/i,
		logCheckpoint,
		takeStepScreenshot,
		'switch-qwen'
	);

	expect(qwenResponse).toContain('6');
	logCheckpoint('Qwen test passed: response contains "6".');

	await deleteActiveChat(page, logCheckpoint, takeStepScreenshot, 'switch-qwen-cleanup');

	// --- Test 2: GPT-5.2 ---
	logCheckpoint('--- Testing GPT-5.2 model via @ mention ---');
	await startNewChat(page, logCheckpoint);

	await selectModelViaMentionDropdown(
		page,
		'gpt-5.2',
		'GPT-5.2',
		logCheckpoint,
		takeStepScreenshot,
		'switch-gpt'
	);

	await typeQuestionAndSend(
		page,
		'What is 5 + 5? Answer with just the number.',
		logCheckpoint,
		takeStepScreenshot,
		'switch-gpt'
	);

	const gptResponse = await waitForResponseAndVerifyModel(
		page,
		/gpt-?5\.?2/i,
		logCheckpoint,
		takeStepScreenshot,
		'switch-gpt'
	);

	expect(gptResponse).toContain('10');
	logCheckpoint('GPT-5.2 test passed: response contains "10".');

	await deleteActiveChat(page, logCheckpoint, takeStepScreenshot, 'switch-gpt-cleanup');

	logCheckpoint('Model switching test completed successfully - both models work via @ mention.');
});
