/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-require-imports */
export {};

const { test, expect } = require('@playwright/test');

const consoleLogs: string[] = [];
const networkActivities: string[] = [];

test.beforeEach(async () => {
	consoleLogs.length = 0;
	networkActivities.length = 0;
});

// eslint-disable-next-line no-empty-pattern
test.afterEach(async ({}, testInfo: any) => {
	if (testInfo.status !== 'passed') {
		console.log('\n--- DEBUG INFO ON FAILURE ---');
		console.log('\n[RECENT CONSOLE LOGS]');
		consoleLogs.slice(-30).forEach((log) => console.log(log));

		console.log('\n[RECENT NETWORK ACTIVITIES]');
		networkActivities.slice(-30).forEach((activity) => console.log(activity));
		console.log('\n--- END DEBUG INFO ---\n');
	}
});

const {
	createSignupLogger,
	archiveExistingScreenshots,
	createStepScreenshotter,
	generateTotp,
	assertNoMissingTranslations
} = require('./signup-flow-helpers');

/**
 * Model override test via MentionDropdown autocomplete.
 *
 * Tests the @mention autocomplete flow for selecting AI models:
 * 1. Type "@" in message input to trigger MentionDropdown
 * 2. Type partial model name to filter results
 * 3. Verify model appears in dropdown
 * 4. Press Tab to autocomplete selection
 * 5. Type question and send message
 * 6. Verify response shows correct model in "generated by" text
 *
 * Based on: docs/architecture/ai_model_selection.md
 * Component: frontend/packages/ui/src/components/enter_message/MentionDropdown.svelte
 *
 * REQUIRED ENV VARS:
 * - OPENMATES_TEST_ACCOUNT_EMAIL: Email of an existing test account.
 * - OPENMATES_TEST_ACCOUNT_PASSWORD: Password for the test account.
 * - OPENMATES_TEST_ACCOUNT_OTP_KEY: 2FA OTP secret (base32) for the test account.
 * - PLAYWRIGHT_TEST_BASE_URL: Base URL for the deployed web app under test.
 */

const TEST_EMAIL = process.env.OPENMATES_TEST_ACCOUNT_EMAIL;
const TEST_PASSWORD = process.env.OPENMATES_TEST_ACCOUNT_PASSWORD;
const TEST_OTP_KEY = process.env.OPENMATES_TEST_ACCOUNT_OTP_KEY;

/**
 * Helper function to log in to the test account.
 */
async function loginToTestAccount(
	page: any,
	logCheckpoint: (message: string, metadata?: Record<string, unknown>) => void,
	takeStepScreenshot: (page: any, label: string) => Promise<void>
): Promise<void> {
	await page.goto('/');
	await takeStepScreenshot(page, 'home');

	const headerLoginButton = page.getByRole('button', {
		name: /login.*sign up|sign up/i
	});
	await expect(headerLoginButton).toBeVisible();
	await headerLoginButton.click();
	await takeStepScreenshot(page, 'login-dialog');

	const emailInput = page.locator('input[name="username"][type="email"]');
	await expect(emailInput).toBeVisible();
	await emailInput.fill(TEST_EMAIL);
	await page.getByRole('button', { name: /continue/i }).click();
	logCheckpoint('Entered email and clicked continue.');

	// Wait for password field with longer timeout - login flow transition may take time
	const passwordInput = page.locator('input[type="password"]');
	await expect(passwordInput).toBeVisible({ timeout: 15000 });
	await passwordInput.fill(TEST_PASSWORD);
	await takeStepScreenshot(page, 'password-entered');

	// Wait for OTP input with longer timeout
	const otpInput = page.locator('input[autocomplete="one-time-code"]');
	await expect(otpInput).toBeVisible({ timeout: 15000 });

	// OTP submission with retry logic for timing edge cases
	const submitLoginButton = page.locator('button[type="submit"]', { hasText: /log in|login/i });
	const errorMessage = page
		.locator('.error-message, [class*="error"]')
		.filter({ hasText: /wrong|invalid|incorrect/i });

	let loginSuccess = false;
	for (let attempt = 1; attempt <= 3 && !loginSuccess; attempt++) {
		// Generate fresh OTP right before submitting to avoid expiration issues
		const otpCode = generateTotp(TEST_OTP_KEY);
		await otpInput.fill(otpCode);
		logCheckpoint(`Generated and entered OTP (attempt ${attempt}).`);
		if (attempt === 1) {
			await takeStepScreenshot(page, 'otp-entered');
		}

		await expect(submitLoginButton).toBeVisible();
		await submitLoginButton.click();
		logCheckpoint('Submitted login form.');

		// Wait for either redirect to chat or error message
		try {
			await page.waitForURL(/chat/, { timeout: 10000 });
			loginSuccess = true;
			logCheckpoint('Logged in successfully, redirected to chat.');
		} catch {
			// Check if there's an error message indicating wrong OTP
			const hasError = await errorMessage.isVisible().catch(() => false);
			if (hasError && attempt < 3) {
				logCheckpoint(`OTP attempt ${attempt} failed, retrying with fresh code...`);
				// Wait for next TOTP window (up to 5 seconds) to ensure fresh code
				await page.waitForTimeout(2000);
			} else if (attempt === 3) {
				// Final attempt failed, throw the error
				throw new Error('Login failed after 3 OTP attempts');
			}
		}
	}

	// Wait for chat interface to fully load
	logCheckpoint('Waiting for chat interface to load...');
	await page.waitForTimeout(5000);

	// Verify we're in the chat - the message editor should be visible
	const messageEditor = page.locator('.editor-content.prose');
	await expect(messageEditor).toBeVisible({ timeout: 15000 });
	logCheckpoint('Chat interface loaded - message editor visible.');
}

/**
 * Helper function to start a new chat session.
 * Attempts to click the new chat button if visible to ensure a fresh state.
 * Based on the pattern in chat-flow.spec.ts.
 */
async function startNewChat(
	page: any,
	logCheckpoint: (message: string, metadata?: Record<string, unknown>) => void
): Promise<void> {
	// Wait a moment for UI to stabilize after any previous operations
	await page.waitForTimeout(1000);

	// Log current URL state
	const currentUrl = page.url();
	logCheckpoint(`Current URL before starting new chat: ${currentUrl}`);

	// Try to click the New Chat button if visible
	// The button may not be visible if we're already in a fresh chat state
	// Try multiple selectors since the button can appear in different places
	const newChatButtonSelectors = [
		'.icon_create',
		'.new-chat-cta-button',
		'button[aria-label*="New"]',
		'button[aria-label*="new"]'
	];

	for (const selector of newChatButtonSelectors) {
		const button = page.locator(selector).first();
		if (await button.isVisible({ timeout: 2000 }).catch(() => false)) {
			logCheckpoint(`Found New Chat button with selector: ${selector}`);
			await button.click();
			await page.waitForTimeout(2000); // Wait for new chat to initialize
			break;
		}
	}

	// Log the state after attempting to start a new chat
	const newUrl = page.url();
	logCheckpoint(`URL after attempting to start new chat: ${newUrl}`);

	// Log assistant message count for debugging
	const assistantMessages = page.locator('.message-wrapper.assistant');
	const messageCount = await assistantMessages.count();
	logCheckpoint(`Current assistant message count: ${messageCount}`);
}

/**
 * Helper function to select a model via @ mention autocomplete.
 * Types "@" followed by the model search term, waits for dropdown,
 * verifies the model appears, and presses Tab to autocomplete.
 *
 * @param page - Playwright page object
 * @param modelSearchTerm - Partial model name to search (e.g., "qwen3" or "gpt-5.2")
 * @param expectedModelDisplayName - Expected model name in dropdown (for verification)
 * @param logCheckpoint - Logging function
 * @param takeStepScreenshot - Screenshot function
 * @param stepLabel - Label for screenshots
 */
async function selectModelViaMentionDropdown(
	page: any,
	modelSearchTerm: string,
	expectedModelDisplayName: string,
	logCheckpoint: (message: string, metadata?: Record<string, unknown>) => void,
	takeStepScreenshot: (page: any, label: string) => Promise<void>,
	stepLabel: string
): Promise<void> {
	const messageEditor = page.locator('.editor-content.prose');
	await expect(messageEditor).toBeVisible();
	await messageEditor.click();
	logCheckpoint('Clicked on message editor.');

	// Type "@" to trigger the mention dropdown
	await page.keyboard.type('@');
	logCheckpoint('Typed "@" to trigger mention dropdown.');
	await page.waitForTimeout(500);

	// Type the model search term to filter
	await page.keyboard.type(modelSearchTerm);
	logCheckpoint(`Typed model search term: "${modelSearchTerm}"`);
	await page.waitForTimeout(500);

	// Wait for the mention dropdown to appear with increased timeout
	const mentionDropdown = page.locator('.mention-dropdown');
	await expect(mentionDropdown).toBeVisible({ timeout: 10000 });
	logCheckpoint('Mention dropdown is visible.');
	await takeStepScreenshot(page, `${stepLabel}-dropdown-visible`);

	// Verify the expected model appears in the dropdown results
	// The model name is shown in .result-name within .mention-result
	const modelResult = mentionDropdown.locator('.mention-result .result-name', {
		hasText: new RegExp(expectedModelDisplayName, 'i')
	});

	await expect(modelResult).toBeVisible({ timeout: 10000 });
	logCheckpoint(`Model "${expectedModelDisplayName}" found in dropdown.`);
	await takeStepScreenshot(page, `${stepLabel}-model-in-dropdown`);

	// Press Tab to autocomplete the selection
	// According to MentionDropdown.svelte, Tab key selects the current result
	await page.keyboard.press('Tab');
	logCheckpoint('Pressed Tab to autocomplete model selection.');
	await page.waitForTimeout(500);

	// Verify dropdown is closed after selection
	await expect(mentionDropdown).not.toBeVisible({ timeout: 3000 });
	logCheckpoint('Mention dropdown closed after selection.');
	await takeStepScreenshot(page, `${stepLabel}-model-selected`);

	// Debug: Log what was actually typed/inserted into the editor
	const editorAfterSelection = page.locator('.editor-content.prose');
	const editorContent = await editorAfterSelection.textContent();
	logCheckpoint(`Editor content after model selection: "${editorContent}"`);
}

/**
 * Helper function to type a question and send the message.
 * Assumes the model has already been selected via @ mention.
 *
 * Note: When sending from a demo chat, the URL may not change to show the new chat ID.
 * This is expected behavior - demo chats create background chats without URL updates.
 */
async function typeQuestionAndSend(
	page: any,
	question: string,
	logCheckpoint: (message: string, metadata?: Record<string, unknown>) => void,
	takeStepScreenshot: (page: any, label: string) => Promise<void>,
	stepLabel: string
): Promise<void> {
	// Type a space after the autocompleted model, then the question
	await page.keyboard.type(' ' + question);
	logCheckpoint(`Typed question: "${question}"`);
	await takeStepScreenshot(page, `${stepLabel}-question-typed`);

	// Click send button
	const sendButton = page.locator('.send-button');
	await expect(sendButton).toBeEnabled();
	await sendButton.click();
	logCheckpoint('Clicked send button.');
	await takeStepScreenshot(page, `${stepLabel}-message-sent`);

	// Note: We don't wait for URL to change because:
	// 1. Demo chats don't update the URL when you send messages
	// 2. The chat is created in the background
	// Instead, we'll verify the message was received by waiting for the response
	logCheckpoint('Message sent - waiting for assistant response...');
}

/**
 * Helper function to wait for assistant response and verify the model used.
 * Checks the "generated by" text under the assistant message.
 *
 * @returns The assistant response text content
 */
async function waitForResponseAndVerifyModel(
	page: any,
	expectedModelPattern: RegExp,
	logCheckpoint: (message: string, metadata?: Record<string, unknown>) => void,
	takeStepScreenshot: (page: any, label: string) => Promise<void>,
	stepLabel: string
): Promise<string> {
	logCheckpoint('Waiting for assistant response...');

	// Count existing assistant messages before waiting for new one
	const initialCount = await page.locator('.message-wrapper.assistant').count();
	logCheckpoint(`Initial assistant message count: ${initialCount}`);

	// Wait for a NEW assistant message to appear (count should increase)
	await expect(async () => {
		const currentCount = await page.locator('.message-wrapper.assistant').count();
		expect(currentCount).toBeGreaterThan(initialCount);
	}).toPass({ timeout: 60000 });

	// Get the last (newest) assistant message
	const assistantMessage = page.locator('.message-wrapper.assistant').last();
	await expect(assistantMessage).toBeVisible({ timeout: 10000 });

	// Wait for streaming to complete - the "generated by" text appears after streaming ends
	// The generated-by element is INSIDE the message wrapper, so we need to scope it
	const generatedByElement = assistantMessage.locator('.generated-by-container .generated-by');
	await expect(generatedByElement).toBeVisible({ timeout: 90000 });
	logCheckpoint('Response complete - generated-by element visible.');
	await takeStepScreenshot(page, `${stepLabel}-response-complete`);

	// Get the model name from the generated-by text
	const generatedByText = await generatedByElement.textContent();
	logCheckpoint(`Generated by text: "${generatedByText}"`);

	// Verify the model name matches expected pattern
	expect(generatedByText).toMatch(expectedModelPattern);
	logCheckpoint(`Verified model matches pattern: ${expectedModelPattern}`);

	// Get the full response text
	const responseText = await assistantMessage.textContent();
	return responseText || '';
}

/**
 * Helper function to delete the active chat.
 * Based on the working pattern from chat-flow.spec.ts.
 *
 * This is a best-effort cleanup function - it will attempt to delete
 * but won't fail the test if it can't (e.g., if we're on a demo chat
 * that can't be deleted).
 */
async function deleteActiveChat(
	page: any,
	logCheckpoint: (message: string, metadata?: Record<string, unknown>) => void,
	takeStepScreenshot: (page: any, label: string) => Promise<void>,
	stepLabel: string
): Promise<void> {
	logCheckpoint('Attempting to delete the chat (best-effort cleanup)...');

	try {
		// Ensure sidebar is open (if on mobile/narrow screen)
		const sidebarToggle = page.locator('.sidebar-toggle-button');
		if (await sidebarToggle.isVisible()) {
			await sidebarToggle.click();
			await page.waitForTimeout(500);
		}

		// Find the active chat in the sidebar
		const activeChatItem = page.locator('.chat-item-wrapper.active');

		// Check if the active chat is visible
		if (!(await activeChatItem.isVisible({ timeout: 5000 }).catch(() => false))) {
			logCheckpoint('No active chat item visible - skipping cleanup.');
			return;
		}
		logCheckpoint('Active chat item is visible.');

		// Debug: Get the chat title if available
		try {
			const chatTitle = await activeChatItem.locator('.chat-title').textContent();
			logCheckpoint(`Active chat title: "${chatTitle}"`);

			// Skip deletion for demo chats
			if (
				chatTitle &&
				(chatTitle.includes('demo') ||
					chatTitle.includes('Demo') ||
					chatTitle.includes('OpenMates'))
			) {
				logCheckpoint('Skipping deletion - appears to be a demo chat.');
				return;
			}
		} catch {
			logCheckpoint('Could not get active chat title.');
		}

		// Right-click to open context menu
		await activeChatItem.click({ button: 'right' });
		await takeStepScreenshot(page, `${stepLabel}-context-menu-open`);
		logCheckpoint('Opened chat context menu.');

		// Wait for context menu and check if delete button is visible
		await page.waitForTimeout(300);
		const deleteButton = page.locator('.menu-item.delete');

		if (!(await deleteButton.isVisible({ timeout: 3000 }).catch(() => false))) {
			logCheckpoint('Delete button not visible in context menu - skipping cleanup.');
			// Press Escape to close context menu
			await page.keyboard.press('Escape');
			return;
		}

		// Click delete button (first time to enter confirm mode)
		await deleteButton.click();
		await takeStepScreenshot(page, `${stepLabel}-delete-confirm-mode`);
		logCheckpoint('Clicked delete, now in confirm mode.');

		// Click delete button again to confirm
		await deleteButton.click();
		logCheckpoint('Confirmed chat deletion.');

		// Verify chat is removed (should redirect to home or another chat)
		await expect(activeChatItem).not.toBeVisible({ timeout: 10000 });
		await takeStepScreenshot(page, `${stepLabel}-chat-deleted`);
		logCheckpoint('Verified chat deletion successfully.');
	} catch (error) {
		// Log the error but don't fail the test - cleanup is best-effort
		logCheckpoint(`Cleanup failed (non-fatal): ${error}`);
	}
}

/**
 * Test: Select Qwen model via @ mention dropdown and verify it's used.
 *
 * Flow:
 * 1. Type "@qwen" in message input
 * 2. Verify "Qwen 3 256b" appears in MentionDropdown
 * 3. Press Tab to autocomplete
 * 4. Type "Capital city of Germany? short answer please."
 * 5. Send message
 * 6. Verify response shows "Qwen" in generated-by text
 */
test('select qwen model via @ mention dropdown', async ({ page }: { page: any }) => {
	page.on('console', (msg: any) => {
		const timestamp = new Date().toISOString();
		consoleLogs.push(`[${timestamp}] [${msg.type()}] ${msg.text()}`);
	});

	page.on('request', (request: any) => {
		const timestamp = new Date().toISOString();
		networkActivities.push(`[${timestamp}] >> ${request.method()} ${request.url()}`);
	});

	page.on('response', (response: any) => {
		const timestamp = new Date().toISOString();
		networkActivities.push(`[${timestamp}] << ${response.status()} ${response.url()}`);
	});

	test.slow();
	test.setTimeout(180000);

	const logCheckpoint = createSignupLogger('MODEL_MENTION_QWEN');
	const takeStepScreenshot = createStepScreenshotter(logCheckpoint, { filenamePrefix: 'qwen' });

	test.skip(!TEST_EMAIL, 'OPENMATES_TEST_ACCOUNT_EMAIL is required.');
	test.skip(!TEST_PASSWORD, 'OPENMATES_TEST_ACCOUNT_PASSWORD is required.');
	test.skip(!TEST_OTP_KEY, 'OPENMATES_TEST_ACCOUNT_OTP_KEY is required.');

	await archiveExistingScreenshots(logCheckpoint);

	logCheckpoint('Starting Qwen model mention test.', { email: TEST_EMAIL });

	// Login
	await loginToTestAccount(page, logCheckpoint, takeStepScreenshot);

	// Start a new chat
	await startNewChat(page, logCheckpoint);

	// Select Qwen model via @ mention dropdown
	// Search term "qwen" should find "Qwen 3 256b" in the dropdown
	await selectModelViaMentionDropdown(
		page,
		'qwen',
		'Qwen',
		logCheckpoint,
		takeStepScreenshot,
		'qwen'
	);

	// Type the question and send
	await typeQuestionAndSend(
		page,
		'Capital city of Germany? short answer please.',
		logCheckpoint,
		takeStepScreenshot,
		'qwen'
	);

	// Wait for response and verify Qwen model was used
	// The generated-by text should contain "Qwen" (case-insensitive)
	const response = await waitForResponseAndVerifyModel(
		page,
		/qwen/i,
		logCheckpoint,
		takeStepScreenshot,
		'qwen'
	);

	// Verify the response contains the expected answer
	expect(response.toLowerCase()).toContain('berlin');
	logCheckpoint('Verified response contains "Berlin".');

	// Verify no missing translations on the chat page
	await assertNoMissingTranslations(page);
	logCheckpoint('No missing translations detected.');

	// Cleanup
	await deleteActiveChat(page, logCheckpoint, takeStepScreenshot, 'qwen-cleanup');

	logCheckpoint('Qwen model mention test completed successfully.');
});

/**
 * Test: Select GPT-5.2 model via @ mention dropdown and verify it's used.
 *
 * Flow:
 * 1. Type "@gpt-5.2" in message input
 * 2. Verify "GPT-5.2" appears in MentionDropdown
 * 3. Press Tab to autocomplete
 * 4. Type "Capital city of Germany? short answer please."
 * 5. Send message
 * 6. Verify response shows "GPT-5.2" in generated-by text
 */
test('select gpt-5.2 model via @ mention dropdown', async ({ page }: { page: any }) => {
	page.on('console', (msg: any) => {
		const timestamp = new Date().toISOString();
		consoleLogs.push(`[${timestamp}] [${msg.type()}] ${msg.text()}`);
	});

	page.on('request', (request: any) => {
		const timestamp = new Date().toISOString();
		networkActivities.push(`[${timestamp}] >> ${request.method()} ${request.url()}`);
	});

	page.on('response', (response: any) => {
		const timestamp = new Date().toISOString();
		networkActivities.push(`[${timestamp}] << ${response.status()} ${response.url()}`);
	});

	test.slow();
	test.setTimeout(180000);

	const logCheckpoint = createSignupLogger('MODEL_MENTION_GPT');
	const takeStepScreenshot = createStepScreenshotter(logCheckpoint, { filenamePrefix: 'gpt' });

	test.skip(!TEST_EMAIL, 'OPENMATES_TEST_ACCOUNT_EMAIL is required.');
	test.skip(!TEST_PASSWORD, 'OPENMATES_TEST_ACCOUNT_PASSWORD is required.');
	test.skip(!TEST_OTP_KEY, 'OPENMATES_TEST_ACCOUNT_OTP_KEY is required.');

	await archiveExistingScreenshots(logCheckpoint);

	logCheckpoint('Starting GPT-5.2 model mention test.', { email: TEST_EMAIL });

	// Login
	await loginToTestAccount(page, logCheckpoint, takeStepScreenshot);

	// Start a new chat
	await startNewChat(page, logCheckpoint);

	// Select GPT-5.2 via @ mention dropdown
	// Search term "gpt-5.2" should find "GPT-5.2" in the dropdown
	await selectModelViaMentionDropdown(
		page,
		'gpt-5.2',
		'GPT-5.2',
		logCheckpoint,
		takeStepScreenshot,
		'gpt'
	);

	// Type the question and send
	await typeQuestionAndSend(
		page,
		'Capital city of Germany? short answer please.',
		logCheckpoint,
		takeStepScreenshot,
		'gpt'
	);

	// Wait for response and verify GPT-5.2 model was used
	// The generated-by text should contain "GPT-5.2" (case-insensitive)
	const response = await waitForResponseAndVerifyModel(
		page,
		/gpt-?5\.?2/i,
		logCheckpoint,
		takeStepScreenshot,
		'gpt'
	);

	// Verify the response contains the expected answer
	expect(response.toLowerCase()).toContain('berlin');
	logCheckpoint('Verified response contains "Berlin".');

	// Cleanup
	await deleteActiveChat(page, logCheckpoint, takeStepScreenshot, 'gpt-cleanup');

	logCheckpoint('GPT-5.2 model mention test completed successfully.');
});

/**
 * Test: Switch between models in the same session using @ mention dropdown.
 *
 * Flow:
 * 1. Login once
 * 2. Test Qwen: Select via @qwen, send question, verify response
 * 3. Delete chat
 * 4. Test GPT-5.2: Select via @gpt-5.2, send question, verify response
 * 5. Delete chat
 */
test('switch between qwen and gpt-5.2 via @ mention dropdown', async ({ page }: { page: any }) => {
	page.on('console', (msg: any) => {
		const timestamp = new Date().toISOString();
		consoleLogs.push(`[${timestamp}] [${msg.type()}] ${msg.text()}`);
	});

	page.on('request', (request: any) => {
		const timestamp = new Date().toISOString();
		networkActivities.push(`[${timestamp}] >> ${request.method()} ${request.url()}`);
	});

	page.on('response', (response: any) => {
		const timestamp = new Date().toISOString();
		networkActivities.push(`[${timestamp}] << ${response.status()} ${response.url()}`);
	});

	test.slow();
	test.setTimeout(300000);

	const logCheckpoint = createSignupLogger('MODEL_MENTION_SWITCH');
	const takeStepScreenshot = createStepScreenshotter(logCheckpoint, { filenamePrefix: 'switch' });

	test.skip(!TEST_EMAIL, 'OPENMATES_TEST_ACCOUNT_EMAIL is required.');
	test.skip(!TEST_PASSWORD, 'OPENMATES_TEST_ACCOUNT_PASSWORD is required.');
	test.skip(!TEST_OTP_KEY, 'OPENMATES_TEST_ACCOUNT_OTP_KEY is required.');

	await archiveExistingScreenshots(logCheckpoint);

	logCheckpoint('Starting model switching test.', { email: TEST_EMAIL });

	// Login once
	await loginToTestAccount(page, logCheckpoint, takeStepScreenshot);

	// --- Test 1: Qwen ---
	logCheckpoint('--- Testing Qwen model via @ mention ---');
	await startNewChat(page, logCheckpoint);

	await selectModelViaMentionDropdown(
		page,
		'qwen',
		'Qwen',
		logCheckpoint,
		takeStepScreenshot,
		'switch-qwen'
	);

	await typeQuestionAndSend(
		page,
		'What is 3 + 3? Answer with just the number.',
		logCheckpoint,
		takeStepScreenshot,
		'switch-qwen'
	);

	const qwenResponse = await waitForResponseAndVerifyModel(
		page,
		/qwen/i,
		logCheckpoint,
		takeStepScreenshot,
		'switch-qwen'
	);

	expect(qwenResponse).toContain('6');
	logCheckpoint('Qwen test passed: response contains "6".');

	await deleteActiveChat(page, logCheckpoint, takeStepScreenshot, 'switch-qwen-cleanup');

	// --- Test 2: GPT-5.2 ---
	logCheckpoint('--- Testing GPT-5.2 model via @ mention ---');
	await startNewChat(page, logCheckpoint);

	await selectModelViaMentionDropdown(
		page,
		'gpt-5.2',
		'GPT-5.2',
		logCheckpoint,
		takeStepScreenshot,
		'switch-gpt'
	);

	await typeQuestionAndSend(
		page,
		'What is 5 + 5? Answer with just the number.',
		logCheckpoint,
		takeStepScreenshot,
		'switch-gpt'
	);

	const gptResponse = await waitForResponseAndVerifyModel(
		page,
		/gpt-?5\.?2/i,
		logCheckpoint,
		takeStepScreenshot,
		'switch-gpt'
	);

	expect(gptResponse).toContain('10');
	logCheckpoint('GPT-5.2 test passed: response contains "10".');

	await deleteActiveChat(page, logCheckpoint, takeStepScreenshot, 'switch-gpt-cleanup');

	logCheckpoint('Model switching test completed successfully - both models work via @ mention.');
});
