<!-- frontend/packages/ui/src/components/settings/appSettings/AppEmbedsPanel.svelte
     Component for displaying all embeds for a specific app in the App Store settings.
     
     This component shows embeds stored in IndexedDB that were generated by the app's skills.
     Embeds are displayed grouped by skill for easy browsing.
-->

<script lang="ts">
    import { onMount } from 'svelte';
    import { text } from '@repo/ui';
    import { embedStore } from '../../../services/embedStore';
    import { resolveEmbed, decodeToonContent } from '../../../services/embedResolver';
    import type { EmbedStoreEntry } from '../../../message_parsing/types';
    import { appSkillsStore } from '../../../stores/appSkillsStore';
    
    // Import embed preview components
    import WebSearchEmbedPreview from '../../../components/embeds/web/WebSearchEmbedPreview.svelte';
    import NewsSearchEmbedPreview from '../../../components/embeds/news/NewsSearchEmbedPreview.svelte';
    import VideosSearchEmbedPreview from '../../../components/embeds/videos/VideosSearchEmbedPreview.svelte';
    import MapsSearchEmbedPreview from '../../../components/embeds/maps/MapsSearchEmbedPreview.svelte';
    import VideoTranscriptEmbedPreview from '../../../components/embeds/videos/VideoTranscriptEmbedPreview.svelte';

    // Use $props() for component props in Svelte 5
    interface Props {
        appId: string;
    }
    
    let { appId }: Props = $props();

    // Reactive state using $state() rune in Svelte 5
    let embedsLoading = $state(false);
    let embeds = $state<EmbedStoreEntry[]>([]);
    let decryptedEmbeds = $state<Map<string, any>>(new Map());
    
    // Track which embeds are valid (can be rendered)
    // This prevents showing embeds that fail to decrypt or render
    let validEmbedIds = $state<Set<string>>(new Set());
    
    // Pagination state
    const EMBEDS_PER_PAGE = 5;
    let currentPage = $state(1);
    
    // Get app metadata to get skill names
    let storeState = $state(appSkillsStore.getState());
    let app = $derived(storeState.apps[appId]);
    let skills = $derived(app?.skills || []);
    
    // Sort embeds by most recent first and filter out invalid embeds
    // Only show embeds that have been validated as renderable
    let sortedEmbeds = $derived.by(() => {
        return [...embeds]
            .filter(embed => {
                const embedId = embed.contentRef.replace('embed:', '');
                return validEmbedIds.has(embedId);
            })
            .sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
    });
    
    let totalPages = $derived.by(() => Math.ceil(sortedEmbeds.length / EMBEDS_PER_PAGE));
    let paginatedEmbeds = $derived.by(() => {
        const start = (currentPage - 1) * EMBEDS_PER_PAGE;
        const end = start + EMBEDS_PER_PAGE;
        return sortedEmbeds.slice(start, end);
    });

    /**
     * Load embeds for this app from IndexedDB
     * 
     * Only shows embeds that have the correct app_id set in the IndexedDB entry.
     * This ensures we only display embeds that actually belong to this specific app.
     * 
     * Note: Embeds without app_id in IndexedDB are not shown. If needed, a migration
     * should be added to backfill app_id for existing embeds.
     */
    async function loadEmbeds() {
        embedsLoading = true;
        try {
            // Get all embeds for this app using the efficient IndexedDB index on app_id
            // This index ensures we only get embeds that belong to this specific app
            const appEmbeds = await embedStore.getEmbedsByAppId(appId);
            
            // Filter to ensure all embeds have the correct app_id (defensive check)
            // This handles edge cases where the index might return incorrect results
            const filteredEmbeds = appEmbeds.filter(embed => {
                // Only include embeds that have app_id set and match the current app
                if (embed.app_id === appId) {
                    return true;
                }
                // Log warning if we find embeds with mismatched app_id (shouldn't happen with proper index)
                if (embed.app_id && embed.app_id !== appId) {
                    console.warn('[AppEmbedsPanel] Found embed with mismatched app_id:', {
                        embedId: embed.contentRef,
                        expectedAppId: appId,
                        actualAppId: embed.app_id
                    });
                }
                return false;
            });
            
            // Debug: Log embed details to diagnose issues
            console.debug(`[AppEmbedsPanel] Query returned ${appEmbeds.length} embeds for app_id: ${appId}, filtered to ${filteredEmbeds.length} matching embeds`);
            
            embeds = filteredEmbeds;

            if (filteredEmbeds.length > 0) {
                console.debug('[AppEmbedsPanel] Sample embed:', {
                    contentRef: filteredEmbeds[0].contentRef,
                    type: filteredEmbeds[0].type,
                    app_id: filteredEmbeds[0].app_id,
                    skill_id: filteredEmbeds[0].skill_id,
                    createdAt: filteredEmbeds[0].createdAt
                });
            } else if (appEmbeds.length > 0 && filteredEmbeds.length === 0) {
                // This shouldn't happen, but log if it does
                console.warn('[AppEmbedsPanel] All embeds were filtered out - possible index issue');
            }

            // Validate embeds to ensure they can be rendered
            // This filters out embeds that fail to decrypt or don't have a valid preview component
            await validateEmbeds(filteredEmbeds);

            // Reset to first page when embeds are loaded
            currentPage = 1;
        } catch (error) {
            console.error('[AppEmbedsPanel] Error loading embeds:', error);
            embeds = []; // Ensure embeds is empty on error
        } finally {
            embedsLoading = false;
        }
    }

    /**
     * Validate embeds to ensure they can be rendered
     * This checks if embeds can be decrypted and have a valid preview component
     * Only embeds that pass validation will be shown in the list
     */
    async function validateEmbeds(embedEntries: EmbedStoreEntry[]): Promise<void> {
        const newValidEmbedIds = new Set<string>();
        
        // Validate each embed asynchronously
        const validationPromises = embedEntries.map(async (embedEntry) => {
            const embedId = embedEntry.contentRef.replace('embed:', '');
            
            try {
                // Try to decrypt the embed
                const embedData = await decryptEmbed(embedEntry);
                if (!embedData) {
                    console.debug(`[AppEmbedsPanel] Embed ${embedId} failed validation: cannot decrypt`);
                    return;
                }
                
                // Try to get a preview component for this embed
                const previewComponent = await renderEmbedPreview(embedId, embedData, embedEntry);
                if (!previewComponent) {
                    console.debug(`[AppEmbedsPanel] Embed ${embedId} failed validation: cannot render preview`);
                    return;
                }
                
                // Embed passed validation - it can be decrypted and rendered
                newValidEmbedIds.add(embedId);
                console.debug(`[AppEmbedsPanel] Embed ${embedId} passed validation`);
            } catch (error) {
                console.debug(`[AppEmbedsPanel] Embed ${embedId} failed validation:`, error);
                // Don't add to valid set - embed will be hidden
            }
        });
        
        // Wait for all validations to complete
        await Promise.all(validationPromises);
        
        // Update valid embed IDs
        validEmbedIds = newValidEmbedIds;
        
        console.debug(`[AppEmbedsPanel] Validation complete: ${newValidEmbedIds.size} of ${embedEntries.length} embeds are valid`);
    }

    /**
     * Decrypt an embed for display
     */
    async function decryptEmbed(embedEntry: EmbedStoreEntry): Promise<any> {
        const embedId = embedEntry.contentRef.replace('embed:', '');
        
        // Check if already decrypted
        if (decryptedEmbeds.has(embedId)) {
            return decryptedEmbeds.get(embedId);
        }

        try {
            // Resolve the embed (this will decrypt it)
            const embedData = await resolveEmbed(embedId);
            if (embedData) {
                decryptedEmbeds.set(embedId, embedData);
                return embedData;
            }
        } catch (error) {
            console.error('[AppEmbedsPanel] Error decrypting embed:', error);
        }

        return null;
    }

    /**
     * Navigate to next page
     */
    function nextPage() {
        if (currentPage < totalPages) {
            currentPage++;
            // Scroll to top of embeds section when changing pages
            const container = document.querySelector('.embeds-list-container');
            if (container) {
                container.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
    }
    
    /**
     * Navigate to previous page
     */
    function previousPage() {
        if (currentPage > 1) {
            currentPage--;
            // Scroll to top of embeds section when changing pages
            const container = document.querySelector('.embeds-list-container');
            if (container) {
                container.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
    }

    /**
     * Format date for display
     */
    function formatDate(timestamp: number): string {
        const date = new Date(timestamp);
        return date.toLocaleDateString(undefined, {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    /**
     * Open embed in fullscreen view (same as clicking embed in message)
     */
    async function openEmbedFullscreen(
        embedId: string,
        embedData: any,
        embedEntry: EmbedStoreEntry
    ): Promise<void> {
        try {
            const decodedContent = await decodeToonContent(embedData.content);
            if (!decodedContent) {
                console.warn('[AppEmbedsPanel] Cannot open fullscreen - failed to decode content');
                return;
            }

            // Dispatch the same event that embed renderers use
            // This will be handled by the global fullscreen handler (if available)
            const event = new CustomEvent('embedfullscreen', {
                detail: {
                    embedId: embedId,
                    embedData: embedData,
                    decodedContent: decodedContent,
                    embedType: 'app-skill-use',
                    attrs: {
                        type: embedEntry.type,
                        contentRef: embedEntry.contentRef,
                        status: embedData.status || 'finished'
                    }
                },
                bubbles: true
            });
            
            document.dispatchEvent(event);
            console.debug('[AppEmbedsPanel] Dispatched fullscreen event for embed:', embedId);
        } catch (error) {
            console.error('[AppEmbedsPanel] Error opening fullscreen:', error);
        }
    }

    /**
     * Render embed preview component based on app_id and skill_id
     * Returns the appropriate Svelte component with props
     * 
     * Verifies that the embed belongs to the current app before rendering.
     * This is a defensive check to ensure we don't render embeds from other apps.
     */
    async function renderEmbedPreview(
        embedId: string,
        embedData: any,
        embedEntry: EmbedStoreEntry
    ): Promise<{ component: any; props: any } | null> {
        try {
            if (!embedData || !embedData.content) {
                console.warn('[AppEmbedsPanel] No embed content available');
                return null;
            }

            const decodedContent = await decodeToonContent(embedData.content);
            if (!decodedContent) {
                console.warn('[AppEmbedsPanel] Failed to decode embed content');
                return null;
            }

            // Get app_id from embed entry (preferred) or decoded content (fallback)
            const embedAppId = embedEntry.app_id || decodedContent.app_id || '';
            const skillId = embedEntry.skill_id || decodedContent.skill_id || '';
            const status = embedData.status || embedEntry.type || 'finished';

            // Verify that this embed belongs to the current app
            // This is a defensive check to prevent rendering embeds from other apps
            if (embedAppId !== appId) {
                console.warn('[AppEmbedsPanel] Skipping embed - app_id mismatch:', {
                    embedId,
                    expectedAppId: appId,
                    actualAppId: embedAppId,
                    embedEntryAppId: embedEntry.app_id,
                    decodedAppId: decodedContent.app_id
                });
                return null;
            }

            console.debug('[AppEmbedsPanel] Rendering embed preview:', { embedId, appId: embedAppId, skillId, status });

            // Determine which component to use based on app_id and skill_id
            // This matches the logic from AppSkillUseRenderer
            // Use embedAppId (already verified to match appId) instead of appId prop
            if (embedAppId === 'web' && skillId === 'search') {
                return {
                    component: WebSearchEmbedPreview,
                    props: {
                        id: embedId,
                        query: decodedContent.query || '',
                        provider: decodedContent.provider || 'Brave Search',
                        status: status,
                        results: decodedContent.results || [],
                        isMobile: false,
                        onFullscreen: () => openEmbedFullscreen(embedId, embedData, embedEntry)
                    }
                };
            }

            if (embedAppId === 'news' && skillId === 'search') {
                return {
                    component: NewsSearchEmbedPreview,
                    props: {
                        id: embedId,
                        query: decodedContent.query || '',
                        provider: decodedContent.provider || 'Brave Search',
                        status: status,
                        results: decodedContent.results || [],
                        isMobile: false,
                        onFullscreen: () => openEmbedFullscreen(embedId, embedData, embedEntry)
                    }
                };
            }

            if (embedAppId === 'videos' && skillId === 'search') {
                return {
                    component: VideosSearchEmbedPreview,
                    props: {
                        id: embedId,
                        query: decodedContent.query || '',
                        provider: decodedContent.provider || 'Brave Search',
                        status: status,
                        results: decodedContent.results || [],
                        isMobile: false,
                        onFullscreen: () => openEmbedFullscreen(embedId, embedData, embedEntry)
                    }
                };
            }

            if (embedAppId === 'maps' && skillId === 'search') {
                return {
                    component: MapsSearchEmbedPreview,
                    props: {
                        id: embedId,
                        query: decodedContent.query || '',
                        provider: decodedContent.provider || 'Brave Search',
                        status: status,
                        results: decodedContent.results || [],
                        isMobile: false,
                        onFullscreen: () => openEmbedFullscreen(embedId, embedData, embedEntry)
                    }
                };
            }

            if (embedAppId === 'videos' && (skillId === 'get_transcript' || skillId === 'get-transcript')) {
                return {
                    component: VideoTranscriptEmbedPreview,
                    props: {
                        id: embedId,
                        results: decodedContent.results || [],
                        status: status,
                        isMobile: false,
                        onFullscreen: () => openEmbedFullscreen(embedId, embedData, embedEntry)
                    }
                };
            }

            // Fallback: Generic preview (could be enhanced later)
            console.warn('[AppEmbedsPanel] No specific preview component for:', { appId: embedAppId, skillId });
            return null;
        } catch (error) {
            console.error('[AppEmbedsPanel] Error rendering embed preview:', error);
            return null;
        }
    }

    onMount(() => {
        loadEmbeds();

        // Reload embeds when new embeds are stored (listen for storage events)
        const handleStorageChange = () => {
            loadEmbeds();
        };

        // Listen for custom event when embeds are stored
        window.addEventListener('embedStored', handleStorageChange);

        return () => {
            window.removeEventListener('embedStored', handleStorageChange);
        };
    });
</script>

<div class="app-embeds">
    {#if embedsLoading}
        <div class="loading">
            <div class="spinner"></div>
            <p>{$text('settings.app_embeds.loading.text')}</p>
        </div>
    {:else if sortedEmbeds.length === 0}
        <div class="empty">
            <p>{$text('settings.app_embeds.no_embeds.text')}</p>
        </div>
    {:else}
        <div class="embeds-list-container">
            <div class="embeds-list">
                {#each paginatedEmbeds as embedEntry (embedEntry.contentRef)}
                    {@const embedId = embedEntry.contentRef.replace('embed:', '')}
                    <div class="embed-item">
                        <div class="embed-header">
                            <span class="embed-meta">
                                {formatDate(embedEntry.createdAt)}
                            </span>
                        </div>
                        <div class="embed-preview-wrapper">
                            {#await decryptEmbed(embedEntry) then embedData}
                                {#if embedData}
                                    {#await renderEmbedPreview(embedId, embedData, embedEntry) then previewComponent}
                                        {#if previewComponent}
                                            {@const Component = previewComponent.component}
                                            <Component {...previewComponent.props} />
                                        {:else}
                                            <div class="embed-preview-error">
                                                <span>Unable to render embed preview</span>
                                            </div>
                                        {/if}
                                    {:catch error}
                                        <div class="embed-preview-error">
                                            <span>Error rendering preview: {error instanceof Error ? error.message : String(error)}</span>
                                        </div>
                                    {/await}
                                {:else}
                                    <div class="embed-preview-loading">
                                        <span>Decrypting...</span>
                                    </div>
                                {/if}
                            {:catch error}
                                <div class="embed-preview-error">
                                    <span>Failed to decrypt: {error instanceof Error ? error.message : String(error)}</span>
                                </div>
                            {/await}
                        </div>
                    </div>
                {/each}
            </div>
            
            {#if totalPages > 1}
                <div class="pagination">
                    <button
                        class="pagination-button"
                        onclick={previousPage}
                        disabled={currentPage === 1}
                        aria-label="Previous page"
                    >
                        ← Previous
                    </button>
                    <span class="pagination-info">
                        Page {currentPage} of {totalPages} ({sortedEmbeds.length} total)
                    </span>
                    <button
                        class="pagination-button"
                        onclick={nextPage}
                        disabled={currentPage === totalPages}
                        aria-label="Next page"
                    >
                        Next →
                    </button>
                </div>
            {/if}
        </div>
    {/if}
</div>

<style>
    .app-embeds {
        padding: 0.5rem 0;
    }

    .loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
        padding: 2rem;
    }

    .spinner {
        width: 24px;
        height: 24px;
        border: 3px solid var(--color-grey-20);
        border-top-color: var(--color-grey-100);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }

    .empty {
        padding: 2rem;
        text-align: center;
        color: var(--color-grey-100);
    }

    .embeds-list-container {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        /* Ensure container doesn't get cut off */
        min-height: 0;
        overflow: visible;
    }

    .embeds-list {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        /* Ensure list doesn't get cut off */
        min-height: 0;
        overflow: visible;
    }

    .embed-item {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        /* Ensure items don't get cut off */
        min-height: 0;
        overflow: visible;
    }

    .embed-header {
        display: flex;
        justify-content: flex-end;
        align-items: center;
    }

    .embed-meta {
        font-size: 0.85rem;
        color: var(--color-grey-60);
    }

    .embed-preview-wrapper {
        /* Container for embed preview components */
        display: flex;
        justify-content: flex-start;
        /* Ensure previews don't get cut off */
        min-height: 0;
        overflow: visible;
    }

    .embed-preview-loading,
    .embed-preview-error {
        padding: 1rem;
        background: var(--color-grey-10);
        border-radius: 8px;
        border: 1px solid var(--color-grey-20);
        color: var(--color-grey-100);
        font-size: 0.9rem;
    }

    .embed-preview-error {
        color: var(--error-color, #dc3545);
    }

    .pagination {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        padding: 1rem 0;
        border-top: 1px solid var(--color-grey-20);
        margin-top: 1rem;
    }

    .pagination-button {
        padding: 0.5rem 1rem;
        background: var(--color-grey-10);
        border: 1px solid var(--color-grey-20);
        border-radius: 6px;
        color: var(--color-grey-100);
        font-size: 0.9rem;
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease;
    }

    .pagination-button:hover:not(:disabled) {
        background: var(--color-grey-15);
        border-color: var(--color-grey-30);
    }

    .pagination-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .pagination-info {
        font-size: 0.9rem;
        color: var(--color-grey-80);
    }
</style>
