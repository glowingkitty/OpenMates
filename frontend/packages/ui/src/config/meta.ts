import { getCurrentLanguage } from '../i18n/setup';
import { LANGUAGE_CODES } from '../i18n/languages';

// Define interfaces for type safety
export interface MetaTagConfig {
    title: string;
    description: string;
    image: string;
    imageWidth: number;
    imageHeight: number;
    url: string;
    type: string;
    keywords: string[];
    author: string;
    locale: string;
    siteName: string;
    logo: string;
    logoWidth: number;
    logoHeight: number;
}

interface PageMetaTags {
    [key: string]: MetaTagConfig;
}

// Default meta values
export let defaultMeta: MetaTagConfig = {
    title: '',
    description: '',
    image: "/images/og-image.jpg",
    imageWidth: 1200,
    imageHeight: 630,
    url: "https://openmates.org",
    type: "website",
    keywords: [],
    author: "OpenMates Team",
    locale: "en_US",
    siteName: "OpenMates™",
    logo: "/images/logo.png",
    logoWidth: 436,
    logoHeight: 92,
};

// Page-specific meta tags
export let pageMeta: PageMetaTags = {
    // Add a default fallback structure
    for_all_of_us: { ...defaultMeta },
    for_developers: { ...defaultMeta },
    docs: { ...defaultMeta },
    docsApi: { ...defaultMeta },
    docsDesignGuidelines: { ...defaultMeta },
    docsDesignSystem: { ...defaultMeta },
    docsRoadmap: { ...defaultMeta },
    docsUserGuide: { ...defaultMeta },
    legalImprint: { ...defaultMeta },
    legalPrivacy: { ...defaultMeta },
    legalTerms: { ...defaultMeta },
    webapp: { ...defaultMeta },
};

/**
 * Static import map for locale files - dynamically generated from languages.json
 * This allows Vite to statically analyze all imports at build time while still
 * allowing dynamic selection at runtime.
 * 
 * IMPORTANT: This function depends on JSON locale files being generated from YAML sources.
 * The JSON files are generated by the `build:translations` script, which runs automatically
 * in the `prebuild` step. This ensures the JSON files exist before the build process tries
 * to import them.
 * 
 * We create a static import map using a helper function that generates import statements
 * for each language code from languages.json. This ensures Vite can statically analyze
 * all imports while using languages.json as the single source of truth.
 */
// Helper function to create import function for a specific language
function createLocaleImport(langCode: string): () => Promise<any> {
    // Use a switch statement to ensure Vite can statically analyze all imports
    // This is more reliable than import.meta.glob in production builds
    switch (langCode) {
        case 'en': return () => import('../i18n/locales/en.json');
        case 'de': return () => import('../i18n/locales/de.json');
        case 'zh': return () => import('../i18n/locales/zh.json');
        case 'es': return () => import('../i18n/locales/es.json');
        case 'fr': return () => import('../i18n/locales/fr.json');
        case 'pt': return () => import('../i18n/locales/pt.json');
        case 'ru': return () => import('../i18n/locales/ru.json');
        case 'ja': return () => import('../i18n/locales/ja.json');
        case 'ko': return () => import('../i18n/locales/ko.json');
        case 'it': return () => import('../i18n/locales/it.json');
        case 'tr': return () => import('../i18n/locales/tr.json');
        case 'vi': return () => import('../i18n/locales/vi.json');
        case 'id': return () => import('../i18n/locales/id.json');
        case 'pl': return () => import('../i18n/locales/pl.json');
        case 'nl': return () => import('../i18n/locales/nl.json');
        case 'ar': return () => import('../i18n/locales/ar.json');
        case 'hi': return () => import('../i18n/locales/hi.json');
        case 'th': return () => import('../i18n/locales/th.json');
        case 'sv': return () => import('../i18n/locales/sv.json');
        case 'cs': return () => import('../i18n/locales/cs.json');
        case 'fi': return () => import('../i18n/locales/fi.json');
        case 'hu': return () => import('../i18n/locales/hu.json');
        case 'ro': return () => import('../i18n/locales/ro.json');
        case 'el': return () => import('../i18n/locales/el.json');
        case 'bg': return () => import('../i18n/locales/bg.json');
        case 'hr': return () => import('../i18n/locales/hr.json');
        case 'sk': return () => import('../i18n/locales/sk.json');
        case 'sl': return () => import('../i18n/locales/sl.json');
        case 'lt': return () => import('../i18n/locales/lt.json');
        case 'lv': return () => import('../i18n/locales/lv.json');
        case 'et': return () => import('../i18n/locales/et.json');
        case 'ga': return () => import('../i18n/locales/ga.json');
        case 'mt': return () => import('../i18n/locales/mt.json');
        default: return () => import('../i18n/locales/en.json'); // Fallback to English
    }
}

/**
 * Create a locale import map from LANGUAGE_CODES
 * This ensures all supported languages have import functions while using
 * languages.json as the single source of truth
 */
function createLocaleImportMap(): Record<string, () => Promise<any>> {
    const map: Record<string, () => Promise<any>> = {};
    
    // Create import functions for each supported language code
    for (const langCode of LANGUAGE_CODES) {
        map[langCode] = createLocaleImport(langCode);
    }
    
    return map;
}

const localeImportMap = createLocaleImportMap();

/**
 * Function to load metatags dynamically based on the current language
 */
export async function loadMetaTags(): Promise<void> {
    try {
        const currentLanguage = getCurrentLanguage();
        let metaData;
        
        // Try to load the current language's metadata using the static import map
        // This allows Vite to statically analyze all imports at build time
        const importFn = localeImportMap[currentLanguage];
        
        if (!importFn) {
            console.warn(`Locale import function not found for language ${currentLanguage}, falling back to English`);
        }
        
        try {
            const loader = importFn || localeImportMap['en'];
            if (!loader) {
                throw new Error('English locale loader not found in import map');
            }
            const module = await loader();
            metaData = module.default || module;
        } catch (e) {
            console.warn(`Metadata for language ${currentLanguage} not found, falling back to English`, e);
            // Fallback to English if current language metadata is not available
            const enLoader = localeImportMap['en'];
            if (!enLoader) {
                throw new Error('English locale loader not found in import map');
            }
            const enModule = await enLoader();
            metaData = enModule.default || enModule;
        }
        
        // Check if metadata exists in the language file
        if (!metaData.metadata || !metaData.metadata.default) {
            console.warn(`Metadata structure missing in language ${currentLanguage}, falling back to English`);
            // Fallback to English metadata
            const enModule = await localeImportMap['en']();
            const enJsonData = enModule.default || enModule;
            
            // If English also doesn't have the metadata structure, use hardcoded defaults
            if (!enJsonData.metadata || !enJsonData.metadata.default) {
                throw new Error('Metadata structure missing in English language file');
            }
            metaData = enJsonData;
        }

        // Update defaultMeta
        defaultMeta = {
            title: metaData.metadata.default.title?.text || "OpenMates",
            description: metaData.metadata.default.description?.text || "",
            image: "/images/og-image.jpg",
            imageWidth: 1200,
            imageHeight: 630,
            url: "https://openmates.org",
            type: "website",
            keywords: (metaData.metadata.default.keywords?.text || "").split(', ').filter(Boolean),
            author: "OpenMates Team",
            locale: `${currentLanguage}_${currentLanguage.toUpperCase()}`,
            siteName: "OpenMates™",
            logo: "/images/logo.png",
            logoWidth: 436,
            logoHeight: 92,
        };

        // Safe function to get nested properties with fallback
        const getMetaProperty = (path: string[], fallback: string = ""): string => {
            let obj = metaData.metadata;
            for (const key of path) {
                if (!obj || typeof obj !== 'object') return fallback;
                obj = obj[key];
            }
            return obj?.text || fallback;
        };

        // Update pageMeta with safe property access
        pageMeta = {
            for_all_of_us: {
                ...defaultMeta,
                title: getMetaProperty(['for_all_of_us', 'title'], defaultMeta.title),
            },
            for_developers: {
                ...defaultMeta,
                title: getMetaProperty(['for_developers', 'title'], defaultMeta.title),
                description: getMetaProperty(['for_developers', 'description'], defaultMeta.description),
            },
            docs: {
                ...defaultMeta,
                title: getMetaProperty(['docs', 'title'], defaultMeta.title),
                description: getMetaProperty(['docs', 'description'], defaultMeta.description),
                type: "article"
            },
            docsApi: {
                ...defaultMeta,
                title: getMetaProperty(['docs_api', 'title'], defaultMeta.title),
                description: getMetaProperty(['docs_api', 'description'], defaultMeta.description),
            },
            docsDesignGuidelines: {
                ...defaultMeta,
                title: getMetaProperty(['docs_design_guidelines', 'title'], defaultMeta.title),
                description: getMetaProperty(['docs_design_guidelines', 'description'], defaultMeta.description),
            },
            docsDesignSystem: {
                ...defaultMeta,
                title: getMetaProperty(['docs_design_system', 'title'], defaultMeta.title),
                description: getMetaProperty(['docs_design_system', 'description'], defaultMeta.description),
            },
            docsRoadmap: {
                ...defaultMeta,
                title: getMetaProperty(['docs_roadmap', 'title'], defaultMeta.title),
                description: getMetaProperty(['docs_roadmap', 'description'], defaultMeta.description),
            },
            docsUserGuide: {
                ...defaultMeta,
                title: getMetaProperty(['docs_user_guide', 'title'], defaultMeta.title),
                description: getMetaProperty(['docs_user_guide', 'description'], defaultMeta.description),
            },
            legalImprint: {
                ...defaultMeta,
                title: getMetaProperty(['legal_imprint', 'title'], defaultMeta.title),
                description: getMetaProperty(['legal_imprint', 'description'], defaultMeta.description),
            },
            legalPrivacy: {
                ...defaultMeta,
                title: getMetaProperty(['legal_privacy', 'title'], defaultMeta.title),
                description: getMetaProperty(['legal_privacy', 'description'], defaultMeta.description),
            },
            legalTerms: {
                ...defaultMeta,
                title: getMetaProperty(['legal_terms', 'title'], defaultMeta.title),
                description: getMetaProperty(['legal_terms', 'description'], defaultMeta.description),
            },
            webapp: {
                ...defaultMeta,
                title: getMetaProperty(['webapp', 'title'], defaultMeta.title),
                description: getMetaProperty(['webapp', 'description'], defaultMeta.description),
                type: "website"
            },
        };
    } catch (error) {
        console.error('Failed to load meta tags:', error);
        // Keep using default values if loading fails
    }
}

// Load meta tags dynamically
loadMetaTags();

// Helper function to get meta tags for a specific page
export function getMetaTags(page: string = 'home'): MetaTagConfig {
    // Ensure we always return a valid meta config even if pageMeta[page] is undefined
    return pageMeta[page] || defaultMeta;
}

// Helper function to generate dynamic meta tags (e.g., for blog posts or docs)
export function generateMetaTags(
    title: string,
    description: string,
    slug: string,
    type: string = 'article',
    keywords?: string[]
): MetaTagConfig {
    return {
        ...defaultMeta,
        title: `${title} | ${defaultMeta.siteName}`,
        description,
        url: `${defaultMeta.url}/${slug}`,
        type,
        keywords: keywords || defaultMeta.keywords
    };
}