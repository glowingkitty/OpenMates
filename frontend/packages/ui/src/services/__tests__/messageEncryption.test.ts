/**
 * Tests for message encryption/decryption in zero-knowledge architecture
 * 
 * This test suite verifies that:
 * 1. Messages are encrypted before being stored in IndexedDB
 * 2. Messages are decrypted when retrieved from IndexedDB
 * 3. The encryption/decryption process maintains data integrity
 * 4. Chat-specific keys are used for encryption
 */

// TODO: currently failing:
// user@server:~/projects/OpenMates/frontend/packages/ui$ npm run test:run -- messageEncryption.test.ts

// > @repo/ui@0.0.0 test:run
// > vitest run messageEncryption.test.ts

// No Svelte config file found in /home/user/projects/OpenMates/frontend/packages/ui - using SvelteKit's default configuration without an adapter.
// Your tsconfig.json should extend the configuration generated by SvelteKit:
// {
//   "extends": "./.svelte-kit/tsconfig.json"
// }
// src/app.html does not exist

// ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ Startup Error ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
// TypeError: Cannot convert undefined or null to object
//     at Function.values (<anonymous>)
//     at configureServer (file:///home/user/projects/OpenMates/node_modules/.pnpm/@sveltejs+vite-plugin-svelte@6.2.0_svelte@5.39.2_vite@7.1.6_@types+node@24.5.2_terser@5.44.0_yaml@2.8.1_/node_modules/@sveltejs/vite-plugin-svelte/src/plugins/hot-update.js:56:37)
//     at _createServer (file:///home/user/projects/OpenMates/node_modules/.pnpm/vite@5.4.20_@types+node@24.5.2_terser@5.44.0/node_modules/vite/dist/node/chunks/dep-D_zLpgQd.js:63336:26)
//     at async createViteServer (file:///home/user/projects/OpenMates/node_modules/.pnpm/vitest@2.1.9_@types+node@24.5.2_jsdom@25.0.1_terser@5.44.0/node_modules/vitest/dist/chunks/cli-api.DqsSTaIi.js:9842:18)
//     at async createVitest (file:///home/user/projects/OpenMates/node_modules/.pnpm/vitest@2.1.9_@types+node@24.5.2_jsdom@25.0.1_terser@5.44.0/node_modules/vitest/dist/chunks/cli-api.DqsSTaIi.js:11461:18)
//     at async prepareVitest (file:///home/user/projects/OpenMates/node_modules/.pnpm/vitest@2.1.9_@types+node@24.5.2_jsdom@25.0.1_terser@5.44.0/node_modules/vitest/dist/chunks/cli-api.DqsSTaIi.js:11884:15)
//     at async startVitest (file:///home/user/projects/OpenMates/node_modules/.pnpm/vitest@2.1.9_@types+node@24.5.2_jsdom@25.0.1_terser@5.44.0/node_modules/vitest/dist/chunks/cli-api.DqsSTaIi.js:11813:15)
//     at async start (file:///home/user/projects/OpenMates/node_modules/.pnpm/vitest@2.1.9_@types+node@24.5.2_jsdom@25.0.1_terser@5.44.0/node_modules/vitest/dist/chunks/cac.CB_9Zo9Q.js:1506:17)
//     at async CAC.run (file:///home/user/projects/OpenMates/node_modules/.pnpm/vitest@2.1.9_@types+node@24.5.2_jsdom@25.0.1_terser@5.44.0/node_modules/vitest/dist/chunks/cac.CB_9Zo9Q.js:1486:3)


import { describe, it, expect, beforeEach, vi } from 'vitest';
import { chatDB } from '../db';
import { generateChatKey, encryptWithChatKey, decryptWithChatKey } from '../cryptoService';
import type { Message } from '../../types/chat';

// Mock IndexedDB
const mockDB = {
  objectStore: vi.fn(),
  index: vi.fn(),
  put: vi.fn(),
  get: vi.fn(),
  getAll: vi.fn(),
  delete: vi.fn(),
  openCursor: vi.fn(),
  createIndex: vi.fn(),
  deleteIndex: vi.fn(),
  indexNames: {
    contains: vi.fn(),
  },
};

const mockTransaction = {
  objectStore: vi.fn(() => mockDB),
  oncomplete: null,
  onerror: null,
  abort: vi.fn(),
};

const mockRequest = {
  result: null,
  error: null,
  onsuccess: null,
  onerror: null,
};

// Mock the database methods
vi.mock('../db', () => ({
  chatDB: {
    init: vi.fn().mockResolvedValue(undefined),
    getTransaction: vi.fn().mockResolvedValue(mockTransaction),
    getChat: vi.fn(),
    getOrGenerateChatKey: vi.fn(),
    encryptMessageFields: vi.fn(),
    decryptMessageFields: vi.fn(),
    saveMessage: vi.fn(),
    getMessagesForChat: vi.fn(),
    getMessage: vi.fn(),
  },
}));

describe('Message Encryption/Decryption', () => {
  let testMessage: Message;
  let testChatId: string;
  let testChatKey: Uint8Array;

  beforeEach(() => {
    // Reset mocks
    vi.clearAllMocks();
    
    // Setup test data
    testChatId = 'test-chat-123';
    testChatKey = generateChatKey();
    
    testMessage = {
      message_id: 'test-message-123',
      chat_id: testChatId,
      role: 'user',
      created_at: Math.floor(Date.now() / 1000),
      status: 'synced',
      encrypted_content: '', // Will be populated by encryption
      encrypted_sender_name: '', // Will be populated by encryption
      encrypted_category: '', // Will be populated by encryption
    };

    // Mock chat key generation
    (chatDB.getOrGenerateChatKey as any).mockReturnValue(testChatKey);
  });

  describe('Message Field Encryption', () => {
    it('should encrypt message content with chat-specific key', () => {
      // Add content to test message
      const messageWithContent = { ...testMessage, content: 'Hello, this is a test message!' };
      
      const encryptedMessage = chatDB.encryptMessageFields(messageWithContent, testChatId);
      
      // Verify that content is encrypted
      expect(encryptedMessage.encrypted_content).toBeDefined();
      expect(encryptedMessage.encrypted_content).not.toBe(messageWithContent.content);
      expect(encryptedMessage.encrypted_content).toMatch(/^[A-Za-z0-9+/=]+$/); // Base64 format
      
      // Verify that plaintext content is still present for AI processing
      expect(encryptedMessage.content).toBe(messageWithContent.content);
    });

    it('should encrypt sender_name with chat-specific key', () => {
      // Add sender_name to test message
      const messageWithSender = { ...testMessage, sender_name: 'Test User' };
      
      const encryptedMessage = chatDB.encryptMessageFields(messageWithSender, testChatId);
      
      // Verify that sender_name is encrypted
      expect(encryptedMessage.encrypted_sender_name).toBeDefined();
      expect(encryptedMessage.encrypted_sender_name).not.toBe(messageWithSender.sender_name);
      expect(encryptedMessage.encrypted_sender_name).toMatch(/^[A-Za-z0-9+/=]+$/); // Base64 format
      
      // Verify that plaintext sender_name is still present for AI processing
      expect(encryptedMessage.sender_name).toBe(messageWithSender.sender_name);
    });

    it('should encrypt category with chat-specific key', () => {
      // Add category to test message
      const messageWithCategory = { ...testMessage, category: 'general' };
      
      const encryptedMessage = chatDB.encryptMessageFields(messageWithCategory, testChatId);
      
      // Verify that category is encrypted
      expect(encryptedMessage.encrypted_category).toBeDefined();
      expect(encryptedMessage.encrypted_category).not.toBe(messageWithCategory.category);
      expect(encryptedMessage.encrypted_category).toMatch(/^[A-Za-z0-9+/=]+$/); // Base64 format
      
      // Verify that plaintext category is still present for AI processing
      expect(encryptedMessage.category).toBe(messageWithCategory.category);
    });
  });

  describe('Message Field Decryption', () => {
    it('should decrypt message content correctly', () => {
      // Add content to test message
      const messageWithContent = { ...testMessage, content: 'Hello, this is a test message!' };
      
      // First encrypt the message
      const encryptedMessage = chatDB.encryptMessageFields(messageWithContent, testChatId);
      
      // Then decrypt it
      const decryptedMessage = chatDB.decryptMessageFields(encryptedMessage, testChatId);
      
      // Verify that content is decrypted correctly
      expect(decryptedMessage.content).toBe(messageWithContent.content);
      expect(decryptedMessage.encrypted_content).toBeUndefined();
    });

    it('should decrypt sender_name correctly', () => {
      // Add sender_name to test message
      const messageWithSender = { ...testMessage, sender_name: 'Test User' };
      
      // First encrypt the message
      const encryptedMessage = chatDB.encryptMessageFields(messageWithSender, testChatId);
      
      // Then decrypt it
      const decryptedMessage = chatDB.decryptMessageFields(encryptedMessage, testChatId);
      
      // Verify that sender_name is decrypted correctly
      expect(decryptedMessage.sender_name).toBe(messageWithSender.sender_name);
      expect(decryptedMessage.encrypted_sender_name).toBeUndefined();
    });

    it('should decrypt category correctly', () => {
      // Add category to test message
      const messageWithCategory = { ...testMessage, category: 'general' };
      
      // First encrypt the message
      const encryptedMessage = chatDB.encryptMessageFields(messageWithCategory, testChatId);
      
      // Then decrypt it
      const decryptedMessage = chatDB.decryptMessageFields(encryptedMessage, testChatId);
      
      // Verify that category is decrypted correctly
      expect(decryptedMessage.category).toBe(messageWithCategory.category);
      expect(decryptedMessage.encrypted_category).toBeUndefined();
    });
  });

  describe('Data Integrity', () => {
    it('should maintain data integrity through encrypt/decrypt cycle', () => {
      // Add content to test message
      const messageWithContent = { 
        ...testMessage, 
        content: 'Hello, this is a test message!',
        sender_name: 'Test User',
        category: 'general'
      };
      
      // Encrypt the message
      const encryptedMessage = chatDB.encryptMessageFields(messageWithContent, testChatId);
      
      // Decrypt the message
      const decryptedMessage = chatDB.decryptMessageFields(encryptedMessage, testChatId);
      
      // Verify that all non-encrypted fields remain unchanged
      expect(decryptedMessage.message_id).toBe(messageWithContent.message_id);
      expect(decryptedMessage.chat_id).toBe(messageWithContent.chat_id);
      expect(decryptedMessage.role).toBe(messageWithContent.role);
      expect(decryptedMessage.created_at).toBe(messageWithContent.created_at);
      expect(decryptedMessage.status).toBe(messageWithContent.status);
      
      // Verify that encrypted fields are properly decrypted
      expect(decryptedMessage.content).toBe(messageWithContent.content);
      expect(decryptedMessage.sender_name).toBe(messageWithContent.sender_name);
      expect(decryptedMessage.category).toBe(messageWithContent.category);
    });

    it('should handle messages without optional fields', () => {
      const minimalMessage: Message = {
        message_id: 'minimal-message-123',
        chat_id: testChatId,
        role: 'user',
        created_at: Math.floor(Date.now() / 1000),
        status: 'synced',
        encrypted_content: '', // Will be populated by encryption
      };

      // Encrypt the message
      const encryptedMessage = chatDB.encryptMessageFields(minimalMessage, testChatId);
      
      // Decrypt the message
      const decryptedMessage = chatDB.decryptMessageFields(encryptedMessage, testChatId);
      
      // Verify that the message is handled correctly
      expect(decryptedMessage.content).toBeUndefined();
      expect(decryptedMessage.sender_name).toBeUndefined();
      expect(decryptedMessage.category).toBeUndefined();
    });
  });

  describe('Chat Key Isolation', () => {
    it('should use different keys for different chats', () => {
      const chatId1 = 'chat-1';
      const chatId2 = 'chat-2';
      const chatKey1 = generateChatKey();
      const chatKey2 = generateChatKey();
      
      // Mock different chat keys
      (chatDB.getOrGenerateChatKey as any)
        .mockReturnValueOnce(chatKey1)
        .mockReturnValueOnce(chatKey2);
      
      // Encrypt the same message with different chat keys
      const encryptedMessage1 = chatDB.encryptMessageFields(testMessage, chatId1);
      const encryptedMessage2 = chatDB.encryptMessageFields(testMessage, chatId2);
      
      // Verify that encrypted content is different
      expect(encryptedMessage1.encrypted_content).not.toBe(encryptedMessage2.encrypted_content);
      expect(encryptedMessage1.encrypted_sender_name).not.toBe(encryptedMessage2.encrypted_sender_name);
      expect(encryptedMessage1.encrypted_category).not.toBe(encryptedMessage2.encrypted_category);
    });
  });

  describe('Error Handling', () => {
    it('should handle missing chat key gracefully', () => {
      // Add content to test message
      const messageWithContent = { ...testMessage, content: 'Hello, this is a test message!' };
      
      // Mock missing chat key
      (chatDB.getOrGenerateChatKey as any).mockReturnValue(null);
      
      const encryptedMessage = chatDB.encryptMessageFields(messageWithContent, testChatId);
      
      // Should return original message without encryption
      expect(encryptedMessage.encrypted_content).toBeUndefined();
      expect(encryptedMessage.content).toBe(messageWithContent.content);
    });

    it('should handle decryption with wrong chat key', () => {
      // Add content to test message
      const messageWithContent = { ...testMessage, content: 'Hello, this is a test message!' };
      
      const correctKey = generateChatKey();
      const wrongKey = generateChatKey();
      
      // Mock correct key for encryption
      (chatDB.getOrGenerateChatKey as any).mockReturnValue(correctKey);
      const encryptedMessage = chatDB.encryptMessageFields(messageWithContent, testChatId);
      
      // Mock wrong key for decryption
      (chatDB.getOrGenerateChatKey as any).mockReturnValue(wrongKey);
      const decryptedMessage = chatDB.decryptMessageFields(encryptedMessage, testChatId);
      
      // Should return original encrypted message without decryption
      expect(decryptedMessage.encrypted_content).toBe(encryptedMessage.encrypted_content);
      expect(decryptedMessage.content).toBeUndefined();
    });
  });
});
