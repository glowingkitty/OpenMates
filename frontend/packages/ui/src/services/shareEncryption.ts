/**
 * Share Encryption Service
 * 
 * This module provides encryption utilities for the share chat feature.
 * It implements the offline-first sharing architecture where all encryption
 * happens on the client side without server involvement.
 * 
 * Key Blob Structure:
 * - chat_encryption_key: The encryption key for the chat (may be password-encrypted if pwd=1)
 * - generated_at: Unix timestamp when the share link was created
 * - duration_seconds: Expiration duration in seconds (0 = no expiration)
 * - pwd: Password protection flag (0 = no password, 1 = password required)
 * 
 * The blob is stored as URL-encoded parameters before encryption and then
 * encrypted with AES-GCM using a key derived from the chat ID.
 * 
 * Architecture reference: /docs/architecture/share_chat.md
 */

// Duration options in seconds
// 0 = no expiration, 60 = 1 minute, 3600 = 1 hour, 86400 = 24 hours, 
// 604800 = 7 days, 1209600 = 14 days, 2592000 = 30 days, 7776000 = 90 days
export type ShareDuration = 0 | 60 | 3600 | 86400 | 604800 | 1209600 | 2592000 | 7776000;

/**
 * Key Blob structure before encryption
 */
interface KeyBlob {
    chat_encryption_key: string;  // Base64 encoded key (may be encrypted if pwd=1)
    generated_at: number;         // Unix timestamp in seconds
    duration_seconds: number;     // Expiration duration (0 = no expiration)
    pwd: 0 | 1;                   // Password flag (0 = no password, 1 = password)
}

/**
 * Derive an encryption key from the chat ID using PBKDF2
 * This creates a deterministic key from the chat ID that can be
 * regenerated by anyone who knows the chat ID.
 * 
 * @param chatId - The unique identifier of the chat
 * @returns A CryptoKey suitable for AES-GCM encryption
 */
async function deriveKeyFromChatId(chatId: string): Promise<CryptoKey> {
    // Convert chat ID to bytes for PBKDF2
    const encoder = new TextEncoder();
    const chatIdBytes = encoder.encode(chatId);
    
    // Use a fixed salt for deterministic key derivation
    // This allows anyone with the chat ID to derive the same key
    const fixedSalt = encoder.encode('openmates-share-v1');
    
    // Import the chat ID as a key material for PBKDF2
    const keyMaterial = await crypto.subtle.importKey(
        'raw',
        chatIdBytes,
        'PBKDF2',
        false,
        ['deriveBits', 'deriveKey']
    );
    
    // Derive a 256-bit AES-GCM key using PBKDF2
    const derivedKey = await crypto.subtle.deriveKey(
        {
            name: 'PBKDF2',
            salt: fixedSalt,
            iterations: 100000,  // High iteration count for security
            hash: 'SHA-256'
        },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
    );
    
    return derivedKey;
}

/**
 * Derive an encryption key from a password using PBKDF2
 * Used for encrypting the chat key when password protection is enabled.
 * 
 * @param password - The user-provided password (max 10 characters)
 * @param chatId - The chat ID used as salt for additional uniqueness
 * @returns A CryptoKey suitable for AES-GCM encryption
 */
async function deriveKeyFromPassword(password: string, chatId: string): Promise<CryptoKey> {
    const encoder = new TextEncoder();
    const passwordBytes = encoder.encode(password);
    
    // Use chat ID as part of the salt for password-derived keys
    // This ensures the same password produces different keys for different chats
    const salt = encoder.encode(`openmates-pwd-${chatId}`);
    
    // Import the password as key material
    const keyMaterial = await crypto.subtle.importKey(
        'raw',
        passwordBytes,
        'PBKDF2',
        false,
        ['deriveBits', 'deriveKey']
    );
    
    // Derive a 256-bit AES-GCM key
    const derivedKey = await crypto.subtle.deriveKey(
        {
            name: 'PBKDF2',
            salt: salt,
            iterations: 100000,
            hash: 'SHA-256'
        },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
    );
    
    return derivedKey;
}

/**
 * Encrypt data using AES-GCM
 * Returns IV + ciphertext as base64 URL-safe string
 * 
 * @param data - The data to encrypt (as Uint8Array)
 * @param key - The encryption key
 * @returns Base64 URL-safe encoded string containing IV + ciphertext
 */
async function encryptAESGCM(data: Uint8Array, key: CryptoKey): Promise<string> {
    // Generate a random 12-byte IV for AES-GCM
    const iv = crypto.getRandomValues(new Uint8Array(12));
    
    // Encrypt the data
    const ciphertext = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        data
    );
    
    // Combine IV + ciphertext
    const combined = new Uint8Array(iv.length + ciphertext.byteLength);
    combined.set(iv);
    combined.set(new Uint8Array(ciphertext), iv.length);
    
    // Convert to base64 URL-safe encoding
    return base64UrlEncode(combined);
}

/**
 * Decrypt data using AES-GCM
 * Expects IV + ciphertext as base64 URL-safe string
 * 
 * @param encryptedData - Base64 URL-safe encoded string containing IV + ciphertext
 * @param key - The decryption key
 * @returns Decrypted data as Uint8Array
 */
async function decryptAESGCM(encryptedData: string, key: CryptoKey): Promise<Uint8Array> {
    // Decode from base64 URL-safe
    const combined = base64UrlDecode(encryptedData);
    
    // Extract IV (first 12 bytes) and ciphertext
    const iv = combined.slice(0, 12);
    const ciphertext = combined.slice(12);
    
    // Decrypt the data
    const decrypted = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        ciphertext
    );
    
    return new Uint8Array(decrypted);
}

/**
 * Base64 URL-safe encoding
 * Replaces + with -, / with _, and removes padding =
 * 
 * @param data - Uint8Array to encode
 * @returns URL-safe base64 string
 */
function base64UrlEncode(data: Uint8Array): string {
    // Convert to regular base64
    const base64 = btoa(String.fromCharCode(...data));
    // Make URL-safe: replace + with -, / with _, remove padding
    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

/**
 * Base64 URL-safe decoding
 * 
 * @param str - URL-safe base64 string
 * @returns Decoded Uint8Array
 */
function base64UrlDecode(str: string): Uint8Array {
    // Restore regular base64: replace - with +, _ with /
    let base64 = str.replace(/-/g, '+').replace(/_/g, '/');
    // Add padding if needed
    while (base64.length % 4) {
        base64 += '=';
    }
    // Decode
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
}

/**
 * Serialize a key blob to URL-encoded string format
 * Format: chat_encryption_key=...&generated_at=...&duration_seconds=...&pwd=0|1
 * 
 * @param blob - The key blob to serialize
 * @returns URL-encoded parameter string
 */
function serializeKeyBlob(blob: KeyBlob): string {
    const params = new URLSearchParams();
    params.set('chat_encryption_key', blob.chat_encryption_key);
    params.set('generated_at', blob.generated_at.toString());
    params.set('duration_seconds', blob.duration_seconds.toString());
    params.set('pwd', blob.pwd.toString());
    return params.toString();
}

/**
 * Deserialize a URL-encoded string back to key blob
 * 
 * @param serialized - URL-encoded parameter string
 * @returns Parsed key blob
 */
function deserializeKeyBlob(serialized: string): KeyBlob {
    const params = new URLSearchParams(serialized);
    return {
        chat_encryption_key: params.get('chat_encryption_key') || '',
        generated_at: parseInt(params.get('generated_at') || '0', 10),
        duration_seconds: parseInt(params.get('duration_seconds') || '0', 10),
        pwd: (parseInt(params.get('pwd') || '0', 10) as 0 | 1)
    };
}

/**
 * Generate an encrypted share key blob
 * 
 * This is the main function for creating a shareable link.
 * It creates an encrypted blob that can be included in the URL fragment.
 * 
 * Architecture:
 * - The blob always contains: chat_encryption_key, generated_at, duration_seconds, pwd
 * - If password protection is enabled (pwd=1), the chat_encryption_key is first encrypted
 *   with a password-derived key before being stored in the blob
 * - The entire blob is then encrypted with a key derived from the chat ID
 * 
 * @param chatId - The unique identifier of the chat
 * @param chatEncryptionKey - The base64-encoded chat encryption key
 * @param durationSeconds - Expiration duration in seconds (0 = no expiration)
 * @param password - Optional password for additional protection (max 10 chars)
 * @returns Encrypted blob as base64 URL-safe string (for use in URL fragment)
 */
export async function generateShareKeyBlob(
    chatId: string,
    chatEncryptionKey: string,
    durationSeconds: ShareDuration = 0,
    password?: string
): Promise<string> {
    console.debug('[ShareEncryption] Generating share key blob', {
        chatId,
        durationSeconds,
        hasPassword: !!password
    });
    
    const encoder = new TextEncoder();
    
    // Prepare the chat encryption key (may be password-encrypted)
    let keyForBlob = chatEncryptionKey;
    let pwdFlag: 0 | 1 = 0;
    
    // If password is provided, encrypt the chat key with password-derived key
    if (password && password.length > 0) {
        console.debug('[ShareEncryption] Encrypting chat key with password');
        const passwordKey = await deriveKeyFromPassword(password, chatId);
        const keyBytes = encoder.encode(chatEncryptionKey);
        keyForBlob = await encryptAESGCM(keyBytes, passwordKey);
        pwdFlag = 1;
    }
    
    // Create the key blob
    const blob: KeyBlob = {
        chat_encryption_key: keyForBlob,
        generated_at: Math.floor(Date.now() / 1000),  // Current Unix timestamp in seconds
        duration_seconds: durationSeconds,
        pwd: pwdFlag
    };
    
    // Serialize the blob to URL-encoded format
    const serialized = serializeKeyBlob(blob);
    console.debug('[ShareEncryption] Serialized blob length:', serialized.length);
    
    // Encrypt the entire blob with chat-ID-derived key
    const chatIdKey = await deriveKeyFromChatId(chatId);
    const blobBytes = encoder.encode(serialized);
    const encryptedBlob = await encryptAESGCM(blobBytes, chatIdKey);
    
    console.debug('[ShareEncryption] Encrypted blob length:', encryptedBlob.length);
    return encryptedBlob;
}

/**
 * Decrypt and parse a share key blob
 * 
 * This is used when accessing a shared link to extract the chat encryption key.
 * 
 * Steps:
 * 1. Decrypt the blob with chat-ID-derived key
 * 2. Parse the blob parameters
 * 3. If pwd=1, decrypt the chat_encryption_key with password-derived key
 * 4. Validate expiration against provided server time
 * 
 * @param chatId - The chat ID from the URL path
 * @param encryptedBlob - The encrypted blob from the URL fragment
 * @param serverTime - Current server time (Unix timestamp in seconds) for expiration check
 * @param password - Password if the share is password-protected
 * @returns Object with decrypted chat key and validation result
 */
export async function decryptShareKeyBlob(
    chatId: string,
    encryptedBlob: string,
    serverTime: number,
    password?: string
): Promise<{
    success: boolean;
    chatEncryptionKey?: string;
    error?: 'expired' | 'password_required' | 'invalid_password' | 'decryption_failed';
}> {
    const decoder = new TextDecoder();
    
    try {
        console.debug('[ShareEncryption] Decrypting share key blob');
        
        // Step 1: Decrypt the blob with chat-ID-derived key
        const chatIdKey = await deriveKeyFromChatId(chatId);
        const decryptedBlobBytes = await decryptAESGCM(encryptedBlob, chatIdKey);
        const serialized = decoder.decode(decryptedBlobBytes);
        
        // Step 2: Parse the blob parameters
        const blob = deserializeKeyBlob(serialized);
        console.debug('[ShareEncryption] Blob parsed:', {
            generated_at: blob.generated_at,
            duration_seconds: blob.duration_seconds,
            pwd: blob.pwd
        });
        
        // Step 3: Check if password is required but not provided
        if (blob.pwd === 1 && !password) {
            return { success: false, error: 'password_required' };
        }
        
        // Step 4: Validate expiration (0 = no expiration)
        if (blob.duration_seconds > 0) {
            const expiresAt = blob.generated_at + blob.duration_seconds;
            if (serverTime > expiresAt) {
                console.debug('[ShareEncryption] Link expired', {
                    serverTime,
                    expiresAt,
                    expired: serverTime > expiresAt
                });
                return { success: false, error: 'expired' };
            }
        }
        
        // Step 5: Extract the chat encryption key
        let chatEncryptionKey = blob.chat_encryption_key;
        
        // If password-protected, decrypt the chat key
        if (blob.pwd === 1 && password) {
            try {
                const passwordKey = await deriveKeyFromPassword(password, chatId);
                const decryptedKeyBytes = await decryptAESGCM(chatEncryptionKey, passwordKey);
                chatEncryptionKey = decoder.decode(decryptedKeyBytes);
            } catch (error) {
                console.debug('[ShareEncryption] Password decryption failed - invalid password');
                return { success: false, error: 'invalid_password' };
            }
        }
        
        return {
            success: true,
            chatEncryptionKey
        };
        
    } catch (error) {
        console.error('[ShareEncryption] Error decrypting share key blob:', error);
        return { success: false, error: 'decryption_failed' };
    }
}

/**
 * Validate if a share link is expired (without full decryption)
 * This is useful for quick checks before attempting full decryption.
 * 
 * Note: This only works if you know the chat ID (to derive the key).
 * The actual validation happens on the client after decrypting the blob.
 * 
 * @param chatId - The chat ID from the URL path
 * @param encryptedBlob - The encrypted blob from the URL fragment
 * @param serverTime - Current server time (Unix timestamp in seconds)
 * @returns Object with validation result
 */
export async function validateShareLinkExpiration(
    chatId: string,
    encryptedBlob: string,
    serverTime: number
): Promise<{
    valid: boolean;
    requiresPassword: boolean;
    expiresAt?: number;
}> {
    const decoder = new TextDecoder();
    
    try {
        // Decrypt the blob with chat-ID-derived key
        const chatIdKey = await deriveKeyFromChatId(chatId);
        const decryptedBlobBytes = await decryptAESGCM(encryptedBlob, chatIdKey);
        const serialized = decoder.decode(decryptedBlobBytes);
        
        // Parse the blob parameters
        const blob = deserializeKeyBlob(serialized);
        
        // Check expiration
        const expiresAt = blob.duration_seconds > 0 
            ? blob.generated_at + blob.duration_seconds 
            : undefined;
        
        const isExpired = expiresAt !== undefined && serverTime > expiresAt;
        
        return {
            valid: !isExpired,
            requiresPassword: blob.pwd === 1,
            expiresAt
        };
        
    } catch (error) {
        console.error('[ShareEncryption] Error validating share link:', error);
        return {
            valid: false,
            requiresPassword: false
        };
    }
}



