/**
 * Embed Share Encryption Service
 *
 * Provides encrypted sharing functionality for embeds, using the same architecture as chat sharing.
 * Uses URL-encoded format and deterministic key derivation from embed ID for compact, efficient sharing.
 * 
 * Architecture (same as chat sharing):
 * - The blob always contains: embed_encryption_key, generated_at, duration_seconds, pwd
 * - If password protection is enabled (pwd=1), the embed_encryption_key is first encrypted
 *   with a password-derived key before being stored in the blob
 * - The entire blob is then encrypted with a key derived from the embed ID
 * - embed_id is NOT included in the blob (it's already in the URL path)
 */

import { embedStore } from './embedStore';

// Re-export ShareDuration type from shareEncryption for consistency
export type { ShareDuration } from './shareEncryption';

/**
 * Structure of the embed share key blob (before encryption)
 * Uses the same compact format as chat sharing: URL-encoded parameters
 * Note: embed_id is NOT included in the blob (it's in the URL path)
 */
interface EmbedShareKeyBlob {
  embed_encryption_key: string;  // Base64 encoded key (may be encrypted if pwd=1)
  generated_at: number;          // Unix timestamp in seconds
  duration_seconds: number;       // Expiration duration (0 = no expiration)
  pwd: 0 | 1;                    // Password flag (0 = no password, 1 = password)
}

/**
 * Derive an encryption key from the embed ID using PBKDF2
 * This creates a deterministic key from the embed ID that can be
 * regenerated by anyone who knows the embed ID.
 * 
 * @param embedId - The unique identifier of the embed
 * @returns A CryptoKey suitable for AES-GCM encryption
 */
async function deriveKeyFromEmbedId(embedId: string): Promise<CryptoKey> {
  const encoder = new TextEncoder();
  const embedIdBytes = encoder.encode(embedId);
  
  // Use a fixed salt for deterministic key derivation (same as chat sharing)
  const fixedSalt = encoder.encode('openmates-share-v1');
  
  // Import the embed ID as key material for PBKDF2
  const keyMaterial = await crypto.subtle.importKey(
    'raw',
    embedIdBytes,
    'PBKDF2',
    false,
    ['deriveBits', 'deriveKey']
  );
  
  // Derive a 256-bit AES-GCM key using PBKDF2
  const derivedKey = await crypto.subtle.deriveKey(
    {
      name: 'PBKDF2',
      salt: fixedSalt,
      iterations: 100000,  // High iteration count for security
      hash: 'SHA-256'
    },
    keyMaterial,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
  
  return derivedKey;
}

/**
 * Derive an encryption key from a password using PBKDF2
 * Used for encrypting the embed key when password protection is enabled.
 * 
 * @param password - The user-provided password (max 10 characters)
 * @param embedId - The embed ID used as salt for additional uniqueness
 * @returns A CryptoKey suitable for AES-GCM encryption
 */
async function deriveKeyFromPassword(password: string, embedId: string): Promise<CryptoKey> {
  const encoder = new TextEncoder();
  const passwordBytes = encoder.encode(password);
  
  // Use embed ID as part of the salt for password-derived keys
  // This ensures the same password produces different keys for different embeds
  const salt = encoder.encode(`openmates-pwd-${embedId}`);
  
  // Import the password as key material
  const keyMaterial = await crypto.subtle.importKey(
    'raw',
    passwordBytes,
    'PBKDF2',
    false,
    ['deriveBits', 'deriveKey']
  );
  
  // Derive a 256-bit AES-GCM key
  const derivedKey = await crypto.subtle.deriveKey(
    {
      name: 'PBKDF2',
      salt: salt,
      iterations: 100000,  // High iteration count for security
      hash: 'SHA-256'
    },
    keyMaterial,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
  
  return derivedKey;
}

/**
 * Encrypt data using AES-GCM
 * Returns IV + ciphertext as base64 URL-safe string
 * 
 * @param data - The data to encrypt (as Uint8Array)
 * @param key - The encryption key
 * @returns Base64 URL-safe encoded string containing IV + ciphertext
 */
async function encryptAESGCM(data: Uint8Array, key: CryptoKey): Promise<string> {
  // Generate a random 12-byte IV for AES-GCM
  const iv = crypto.getRandomValues(new Uint8Array(12));
  
  // Encrypt the data
  const ciphertext = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv: iv },
    key,
    data
  );
  
  // Combine IV + ciphertext
  const combined = new Uint8Array(iv.length + ciphertext.byteLength);
  combined.set(iv);
  combined.set(new Uint8Array(ciphertext), iv.length);
  
  // Convert to base64 URL-safe encoding
  return base64UrlEncode(combined);
}

/**
 * Decrypt data using AES-GCM
 * Expects IV + ciphertext as base64 URL-safe string
 * 
 * @param encryptedData - Base64 URL-safe encoded string containing IV + ciphertext
 * @param key - The decryption key
 * @returns Decrypted data as Uint8Array
 */
async function decryptAESGCM(encryptedData: string, key: CryptoKey): Promise<Uint8Array> {
  // Decode from base64 URL-safe
  const combined = base64UrlDecode(encryptedData);
  
  // Extract IV (first 12 bytes) and ciphertext
  const iv = combined.slice(0, 12);
  const ciphertext = combined.slice(12);
  
  // Decrypt the data
  const decrypted = await crypto.subtle.decrypt(
    { name: 'AES-GCM', iv: iv },
    key,
    ciphertext
  );
  
  return new Uint8Array(decrypted);
}

/**
 * Base64 URL-safe encoding
 * Replaces + with -, / with _, and removes padding =
 * 
 * @param data - Uint8Array to encode
 * @returns URL-safe base64 string
 */
function base64UrlEncode(data: Uint8Array): string {
  // Convert to regular base64
  const base64 = btoa(String.fromCharCode(...data));
  // Make URL-safe: replace + with -, / with _, remove padding
  return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

/**
 * Base64 URL-safe decoding
 * 
 * @param str - URL-safe base64 string
 * @returns Decoded Uint8Array
 */
function base64UrlDecode(str: string): Uint8Array {
  // Restore regular base64: replace - with +, _ with /
  let base64 = str.replace(/-/g, '+').replace(/_/g, '/');
  // Add padding if needed
  while (base64.length % 4) {
    base64 += '=';
  }
  // Decode
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

/**
 * Serialize an embed key blob to URL-encoded string format
 * Format: embed_encryption_key=...&generated_at=...&duration_seconds=...&pwd=0|1
 * 
 * @param blob - The key blob to serialize
 * @returns URL-encoded parameter string
 */
function serializeEmbedKeyBlob(blob: EmbedShareKeyBlob): string {
  const params = new URLSearchParams();
  params.set('embed_encryption_key', blob.embed_encryption_key);
  params.set('generated_at', blob.generated_at.toString());
  params.set('duration_seconds', blob.duration_seconds.toString());
  params.set('pwd', blob.pwd.toString());
  return params.toString();
}

/**
 * Deserialize a URL-encoded string back to embed key blob
 * 
 * @param serialized - URL-encoded parameter string
 * @returns Parsed key blob
 */
function deserializeEmbedKeyBlob(serialized: string): EmbedShareKeyBlob {
  const params = new URLSearchParams(serialized);
  return {
    embed_encryption_key: params.get('embed_encryption_key') || '',
    generated_at: parseInt(params.get('generated_at') || '0', 10),
    duration_seconds: parseInt(params.get('duration_seconds') || '0', 10),
    pwd: (parseInt(params.get('pwd') || '0', 10) as 0 | 1)
  };
}

/**
 * Generate an encrypted embed share key blob
 * 
 * This is the main function for creating a shareable link for embeds.
 * It creates an encrypted blob that can be included in the URL fragment.
 * 
 * Architecture (same as chat sharing):
 * - The blob always contains: embed_encryption_key, generated_at, duration_seconds, pwd
 * - If password protection is enabled (pwd=1), the embed_encryption_key is first encrypted
 *   with a password-derived key before being stored in the blob
 * - The entire blob is then encrypted with a key derived from the embed ID
 * - embed_id is NOT included in the blob (it's already in the URL path)
 * 
 * @param embedId - The unique identifier of the embed
 * @param durationSeconds - Expiration duration in seconds (0 = no expiration)
 * @param password - Optional password for additional protection (max 10 chars)
 * @returns Encrypted blob as base64 URL-safe string (for use in URL fragment)
 */
export async function generateEmbedShareKeyBlob(
  embedId: string,
  durationSeconds: ShareDuration = 0,
  password?: string
): Promise<string> {
  console.debug('[EmbedShareEncryption] Generating embed share key blob', {
    embedId,
    durationSeconds,
    hasPassword: !!password
  });
  
  // Get the embed's encryption key from embedStore
  // CRITICAL: For child embeds, getEmbedKey automatically uses the parent embed's key (key inheritance - Option A)
  // This ensures that when sharing a child embed, we use the parent key in the share link
  // The parent key is what decrypts both parent and child embeds
  const embedKey = await embedStore.getEmbedKey(embedId);
  if (!embedKey) {
    throw new Error(`Embed key not found for embed ID: ${embedId}`);
  }
  
  // Convert embed key to base64 for storage in blob
  const embedKeyBase64 = btoa(String.fromCharCode(...embedKey));
  
  const encoder = new TextEncoder();
  
  // Prepare the embed encryption key (may be password-encrypted)
  let keyForBlob = embedKeyBase64;
  let pwdFlag: 0 | 1 = 0;
  
  // If password is provided, encrypt the embed key with password-derived key
  if (password && password.length > 0) {
    console.debug('[EmbedShareEncryption] Encrypting embed key with password');
    const passwordKey = await deriveKeyFromPassword(password, embedId);
    const keyBytes = encoder.encode(embedKeyBase64);
    keyForBlob = await encryptAESGCM(keyBytes, passwordKey);
    pwdFlag = 1;
  }
  
  // Create the key blob
  const blob: EmbedShareKeyBlob = {
    embed_encryption_key: keyForBlob,
    generated_at: Math.floor(Date.now() / 1000),  // Current Unix timestamp in seconds
    duration_seconds: durationSeconds,
    pwd: pwdFlag
  };
  
  // Serialize the blob to URL-encoded format
  const serialized = serializeEmbedKeyBlob(blob);
  console.debug('[EmbedShareEncryption] Serialized blob length:', serialized.length);
  
  // Encrypt the entire blob with embed-ID-derived key
  const embedIdKey = await deriveKeyFromEmbedId(embedId);
  const blobBytes = encoder.encode(serialized);
  const encryptedBlob = await encryptAESGCM(blobBytes, embedIdKey);
  
  console.debug('[EmbedShareEncryption] Encrypted blob length:', encryptedBlob.length);
  return encryptedBlob;
}

/**
 * Decrypt and parse an embed share key blob
 * 
 * This is used when accessing a shared link to extract the embed encryption key.
 * 
 * Steps:
 * 1. Decrypt the blob with embed-ID-derived key
 * 2. Parse the blob parameters
 * 3. If pwd=1, decrypt the embed_encryption_key with password-derived key
 * 4. Validate expiration against provided server time
 * 
 * @param embedId - The embed ID from the URL path
 * @param encryptedBlob - The encrypted blob from the URL fragment
 * @param serverTime - Current server time (Unix timestamp in seconds) for expiration check
 * @param password - Password if the share is password-protected
 * @returns Object with decrypted embed key and validation result
 */
export async function decryptEmbedShareKeyBlob(
  embedId: string,
  encryptedBlob: string,
  serverTime: number,
  password?: string
): Promise<{
  success: boolean;
  embedKey?: Uint8Array;
  isExpired?: boolean;
  error?: 'expired' | 'password_required' | 'invalid_password' | 'decryption_failed';
}> {
  const decoder = new TextDecoder();
  
  try {
    console.debug('[EmbedShareEncryption] Decrypting embed share key blob');
    
    // Decrypt the blob with embed-ID-derived key
    const embedIdKey = await deriveKeyFromEmbedId(embedId);
    const decryptedBytes = await decryptAESGCM(encryptedBlob, embedIdKey);
    const serialized = decoder.decode(decryptedBytes);
    
    // Parse the blob
    const blob = deserializeEmbedKeyBlob(serialized);
    
    // Check expiration
    if (blob.duration_seconds > 0) {
      const expirationTime = blob.generated_at + blob.duration_seconds;
      if (serverTime > expirationTime) {
        console.warn('[EmbedShareEncryption] Embed share link has expired');
        return {
          success: false,
          isExpired: true,
          error: 'expired'
        };
      }
    }
    
    // If password protected, decrypt the embed key
    let embedKeyBase64: string;
    if (blob.pwd === 1) {
      if (!password) {
        console.warn('[EmbedShareEncryption] Password required for protected embed share');
        return {
          success: false,
          error: 'password_required'
        };
      }
      
      console.debug('[EmbedShareEncryption] Decrypting password-protected embed key');
      const passwordKey = await deriveKeyFromPassword(password, embedId);
      const decryptedKeyBytes = await decryptAESGCM(blob.embed_encryption_key, passwordKey);
      embedKeyBase64 = decoder.decode(decryptedKeyBytes);
    } else {
      embedKeyBase64 = blob.embed_encryption_key;
    }
    
    // Convert base64 embed key back to Uint8Array
    const embedKey = new Uint8Array(
      atob(embedKeyBase64).split('').map(c => c.charCodeAt(0))
    );
    
    console.debug('[EmbedShareEncryption] Embed share key blob decrypted successfully');
    return {
      success: true,
      embedKey,
      isExpired: false
    };
    
  } catch (error) {
    console.error('[EmbedShareEncryption] Error decrypting embed share key blob:', error);
    return {
      success: false,
      error: 'decryption_failed'
    };
  }
}

/**
 * Get an embed's encryption key for sharing
 *
 * Helper function that wraps embedStore.getEmbedKey with proper error handling
 *
 * @param embedId - The embed ID
 * @returns The embed's encryption key or null if not found
 */
export async function getEmbedKeyForSharing(embedId: string): Promise<Uint8Array | null> {
  try {
    const embedKey = await embedStore.getEmbedKey(embedId);
    if (!embedKey) {
      console.warn('[EmbedShareEncryption] Embed key not found for sharing:', embedId);
      return null;
    }
    return embedKey;
  } catch (error) {
    console.error('[EmbedShareEncryption] Error getting embed key for sharing:', error);
    return null;
  }
}
