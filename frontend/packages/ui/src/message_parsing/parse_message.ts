// Main entry point for the unified message parsing architecture
// Handles both write_mode (editing) and read_mode (display) parsing

import { ParseMessageOptions, EmbedNodeAttributes } from './types';
import { markdownToTipTap } from './serializers';
import { parseEmbedNodes } from './embedParsing';
import { handleStreamingSemantics } from './streamingSemantics';
import { enhanceDocumentWithEmbeds } from './documentEnhancement';
import { groupConsecutiveEmbedsInDocument } from './embedGrouping';

/**
 * Unified message parser for both write and read modes
 * @param markdown - The raw markdown content to parse
 * @param mode - 'write' for editing mode, 'read' for display mode
 * @param opts - Parsing options including feature flags
 * @returns TipTap document JSON with unified embed nodes
 */
export function parse_message(markdown: string, mode: 'write' | 'read', opts: ParseMessageOptions = {}): any {
  // If unified parsing is not enabled, fallback to existing behavior
  if (!opts.unifiedParsingEnabled) {
    return markdownToTipTap(markdown);
  }
  
  console.debug('[parse_message] Parsing with unified architecture:', { mode, length: markdown.length });
  
  // First, parse basic markdown structure using existing parser
  const basicDoc = markdownToTipTap(markdown);
  
  // Parse normal embed nodes
  const embedNodes = parseEmbedNodes(markdown, mode);
  
  // Handle streaming semantics for partial/unclosed blocks
  const streamingData = handleStreamingSemantics(markdown, mode);
  
  // Combine normal embeds with partial embeds for write mode
  const allEmbeds = mode === 'write' 
    ? [...embedNodes, ...streamingData.partialEmbeds]
    : embedNodes;
  
  // Create a new document with individual embed nodes first
  // This preserves document structure so we can accurately determine what's consecutive
  const docWithIndividualEmbeds = enhanceDocumentWithEmbeds(basicDoc, allEmbeds, mode);
  
  // Group consecutive embeds of the same type at the document level where we can see actual text between them
  const unifiedDoc = groupConsecutiveEmbedsInDocument(docWithIndividualEmbeds);
  
  // Add streaming metadata for write mode highlighting
  if (mode === 'write' && streamingData.unclosedBlocks.length > 0) {
    unifiedDoc._streamingData = streamingData;
  }
  
  console.debug('[parse_message] Created unified document with embeds:', { 
    individualEmbedCount: allEmbeds.length,
    unclosedBlocks: streamingData.unclosedBlocks.length,
    mode 
  });
  
  return unifiedDoc;
}