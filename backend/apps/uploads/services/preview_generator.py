# backend/apps/uploads/services/preview_generator.py
#
# Image processing service for uploaded files.
#
# Produces the SAME three variants as the image generation pipeline (generate_task.py):
#
#   - original    — Re-encoded with preserved format (no XMP/C2PA for user uploads)
#   - full_webp   — Full-size WEBP at quality 90
#   - preview_webp — Cropped/resized WEBP matching generate_task.py logic:
#                     * Horizontal/Square: 600×400 px (aspect-crop)
#                     * Vertical: fixed 400px height, proportional width
#
# Intentionally mirrors process_image_for_storage() from the core API so both
# flows produce identical preview dimensions and quality settings. We do NOT
# import from backend.core because app-uploads must run standalone on a separate VM.
#
# All Pillow operations run inside asyncio.to_thread() to avoid blocking the event loop.

import asyncio
import io
import logging

logger = logging.getLogger(__name__)

# Preview target dimensions — must match process_image_for_storage() in the core API
PREVIEW_TARGET_W = 600
PREVIEW_TARGET_H = 400
FULL_WEBP_QUALITY = 90     # Same as generate_task.py
PREVIEW_WEBP_QUALITY = 80  # Same as process_image_for_storage() default


class ImagePreviewResult:
    """
    Result of image processing for a single uploaded file.

    Provides processed bytes and dimensions for the three variants that
    mirror the generate_task.py output (original, full, preview).
    """

    def __init__(
        self,
        original_bytes: bytes,
        full_webp_bytes: bytes,
        preview_webp_bytes: bytes,
        original_width: int,
        original_height: int,
        full_width: int,
        full_height: int,
        preview_width: int,
        preview_height: int,
    ) -> None:
        self.original_bytes = original_bytes
        self.full_webp_bytes = full_webp_bytes
        self.preview_webp_bytes = preview_webp_bytes
        self.original_width = original_width
        self.original_height = original_height
        self.full_width = full_width
        self.full_height = full_height
        self.preview_width = preview_width
        self.preview_height = preview_height


def _get_dims(data: bytes) -> tuple[int, int]:
    """Extract (width, height) from image bytes using Pillow."""
    from PIL import Image  # type: ignore[import]
    try:
        img = Image.open(io.BytesIO(data))
        return img.size
    except Exception:
        return (0, 0)


def _process_sync(file_bytes: bytes) -> ImagePreviewResult:
    """
    Synchronous image processing — called via asyncio.to_thread().

    Mirrors process_image_for_storage() from backend.core.api.app.utils.image_processing
    but is self-contained so app-uploads can run on a separate VM without importing
    from the core API package.

    No XMP/C2PA metadata is injected for user uploads since the images are not
    AI-generated by our platform.
    """
    from PIL import Image, UnidentifiedImageError  # type: ignore[import]

    try:
        img = Image.open(io.BytesIO(file_bytes))
    except UnidentifiedImageError as exc:
        raise ValueError(f"Cannot identify image format: {exc}") from exc

    orig_format = img.format or "JPEG"
    original_width, original_height = img.size

    logger.debug(
        f"[PreviewGenerator] Processing {orig_format} image {original_width}x{original_height}"
    )

    # --- Re-encode original (preserve format, no metadata injection for uploads) ---
    orig_buf = io.BytesIO()
    fmt_upper = orig_format.upper()
    if fmt_upper == "PNG":
        img.save(orig_buf, format="PNG")
    elif fmt_upper in ("JPEG", "JPG"):
        img.save(orig_buf, format="JPEG", quality=98)
    elif fmt_upper == "WEBP":
        img.save(orig_buf, format="WEBP", quality=98)
    else:
        # Fallback: convert to WEBP for any other format (GIF, BMP, HEIC, etc.)
        rgb = img.convert("RGB") if img.mode not in ("RGB", "RGBA") else img
        rgb.save(orig_buf, format="WEBP", quality=95)
    original_bytes = orig_buf.getvalue()

    # --- Full-size WEBP (same as process_image_for_storage quality=90) ---
    full_buf = io.BytesIO()
    img.save(full_buf, format="WEBP", quality=FULL_WEBP_QUALITY)
    full_webp_bytes = full_buf.getvalue()

    # --- Preview WEBP — mirrors process_image_for_storage() preview logic ---
    #
    # Horizontal/Square: crop to 600×400 (aspect-ratio crop, centred)
    # Vertical: resize to 400px height, proportional width
    width, height = img.size
    is_vertical = height > width

    if is_vertical:
        # Vertical: fixed 400px height, proportional width
        new_height = PREVIEW_TARGET_H
        new_width = int(width * (new_height / height))
        preview_img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
    else:
        # Horizontal/Square: crop to 600×400
        target_ratio = PREVIEW_TARGET_W / PREVIEW_TARGET_H
        current_ratio = width / height

        if current_ratio > target_ratio:
            # Wider than target: crop sides
            new_width = int(height * target_ratio)
            left = (width - new_width) / 2
            img_cropped = img.crop((left, 0, left + new_width, height))
        else:
            # Taller than target: crop top/bottom
            new_height = int(width / target_ratio)
            top = (height - new_height) / 2
            img_cropped = img.crop((0, top, width, top + new_height))

        preview_img = img_cropped.resize(
            (PREVIEW_TARGET_W, PREVIEW_TARGET_H), Image.Resampling.LANCZOS
        )

    preview_buf = io.BytesIO()
    preview_img.save(preview_buf, format="WEBP", quality=PREVIEW_WEBP_QUALITY)
    preview_webp_bytes = preview_buf.getvalue()

    full_width, full_height = _get_dims(full_webp_bytes)
    preview_width, preview_height = _get_dims(preview_webp_bytes)

    logger.info(
        f"[PreviewGenerator] Done: "
        f"original={original_width}x{original_height} ({len(original_bytes)}B), "
        f"full={full_width}x{full_height} ({len(full_webp_bytes)}B), "
        f"preview={preview_width}x{preview_height} ({len(preview_webp_bytes)}B)"
    )

    return ImagePreviewResult(
        original_bytes=original_bytes,
        full_webp_bytes=full_webp_bytes,
        preview_webp_bytes=preview_webp_bytes,
        original_width=original_width,
        original_height=original_height,
        full_width=full_width,
        full_height=full_height,
        preview_width=preview_width,
        preview_height=preview_height,
    )


class PreviewGeneratorService:
    """
    Async service for processing uploaded images into multiple variants.

    Uses the same processing logic as the image generation skill to ensure
    consistent output quality and preview dimensions across all flows.
    """

    async def generate_image_preview(self, file_bytes: bytes) -> ImagePreviewResult:
        """
        Process an uploaded image into original, full, and preview WEBP variants.

        Runs Pillow processing in a thread pool to avoid blocking the event loop.

        Args:
            file_bytes: Raw uploaded image bytes (any Pillow-supported format).

        Returns:
            ImagePreviewResult with processed bytes and dimensions for all three variants.

        Raises:
            ValueError: If the bytes do not represent a valid image.
            Exception: If Pillow processing fails unexpectedly.
        """
        return await asyncio.to_thread(_process_sync, file_bytes)
