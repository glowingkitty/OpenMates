# backend/apps/uploads/services/malware_scanner.py
#
# ClamAV malware scanning service.
#
# Architecture:
#   - Communicates with a dedicated 'clamav' Docker container via TCP socket (pyclamd).
#   - The ClamAV daemon (clamd) runs in its own container with a freshclam sidecar
#     that keeps virus definitions up to date continuously.
#   - Files are scanned in memory (stream scan) — no temp files written to disk.
#   - Scanning is async-wrapped: pyclamd is synchronous, so we run it in a thread pool
#     to avoid blocking the FastAPI event loop during scans.
#
# Concurrent uploads:
#   - Each upload request runs its scan in asyncio.to_thread(), so multiple
#     simultaneous scans share the clamd daemon's internal queue without blocking.

import asyncio
import logging
from typing import Optional
import os

logger = logging.getLogger(__name__)


class MalwareScanResult:
    """Result of a ClamAV malware scan."""

    def __init__(self, is_clean: bool, threat_name: Optional[str] = None):
        self.is_clean = is_clean
        self.threat_name = threat_name  # e.g. "Win.Malware.Agent-123456" if threat detected

    def __repr__(self) -> str:
        if self.is_clean:
            return "MalwareScanResult(clean)"
        return f"MalwareScanResult(threat={self.threat_name})"


class MalwareScannerService:
    """
    Wrapper around pyclamd for async ClamAV malware scanning.

    Connects to the clamd TCP daemon on startup and scans file bytes in memory.
    Stream scanning avoids writing plaintext files to disk.
    """

    def __init__(self) -> None:
        # ClamAV daemon host/port are injected via environment variables.
        # Defaults match the Docker service names defined in docker-compose.yml.
        self.clamav_host = os.environ.get("CLAMAV_HOST", "clamav")
        self.clamav_port = int(os.environ.get("CLAMAV_PORT", "3310"))
        self._clamd = None  # pyclamd.ClamdNetworkSocket instance, initialized on first use

    def _get_clamd(self):
        """
        Lazily initialise the pyclamd network socket client.
        Called from the thread pool (not the async event loop) since pyclamd is sync.
        """
        if self._clamd is None:
            try:
                import pyclamd  # type: ignore[import]
                self._clamd = pyclamd.ClamdNetworkSocket(
                    host=self.clamav_host,
                    port=self.clamav_port,
                    timeout=30,
                )
                # Verify connectivity
                self._clamd.ping()
                logger.info(
                    f"[ClamAV] Connected to clamd at {self.clamav_host}:{self.clamav_port}"
                )
            except Exception as e:
                logger.error(f"[ClamAV] Failed to connect to clamd: {e}", exc_info=True)
                raise RuntimeError(f"ClamAV daemon unavailable: {e}") from e
        return self._clamd

    def _scan_bytes_sync(self, file_bytes: bytes) -> MalwareScanResult:
        """
        Synchronous stream scan — runs in a thread pool via asyncio.to_thread().

        pyclamd.scan_stream() sends file bytes directly to clamd over the socket
        and returns None (clean) or a dict {stream: ('FOUND', 'ThreatName')} (infected).
        """
        import pyclamd  # type: ignore[import]

        clamd = self._get_clamd()

        try:
            result = clamd.scan_stream(file_bytes)
            if result is None:
                # None means clean
                return MalwareScanResult(is_clean=True)

            # result is {'stream': ('FOUND', 'Threat.Name')}
            threat = result.get("stream", (None, None))
            threat_name = threat[1] if len(threat) > 1 else "Unknown"
            logger.warning(f"[ClamAV] THREAT DETECTED: {threat_name}")
            return MalwareScanResult(is_clean=False, threat_name=threat_name)

        except pyclamd.ConnectionError as e:
            # Connection was lost mid-scan — reset so next call reconnects
            self._clamd = None
            logger.error(f"[ClamAV] Connection lost during scan: {e}", exc_info=True)
            raise RuntimeError(f"ClamAV connection lost: {e}") from e
        except Exception as e:
            logger.error(f"[ClamAV] Scan error: {e}", exc_info=True)
            raise

    async def scan(self, file_bytes: bytes) -> MalwareScanResult:
        """
        Async entry point — wraps the synchronous scan in a thread pool executor
        so the FastAPI event loop is not blocked during the scan.

        Multiple simultaneous calls are handled by asyncio's default ThreadPoolExecutor.

        Args:
            file_bytes: Raw file content to scan (plaintext, before encryption).

        Returns:
            MalwareScanResult with is_clean=True if safe, False if threat detected.

        Raises:
            RuntimeError: If clamd is unreachable or scan fails.
        """
        logger.info(f"[ClamAV] Starting stream scan ({len(file_bytes)} bytes)")
        result = await asyncio.to_thread(self._scan_bytes_sync, file_bytes)
        logger.info(f"[ClamAV] Scan complete: {result}")
        return result

    async def health_check(self) -> bool:
        """
        Ping the ClamAV daemon to verify it is reachable.
        Used by the /health endpoint.
        """
        try:
            await asyncio.to_thread(self._get_clamd)
            return True
        except Exception:
            return False
