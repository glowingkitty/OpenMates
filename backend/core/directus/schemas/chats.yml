chats:
  type: collection
  fields:
    id: # chat_id
      type: uuid
      note: "Primary Key - Unique identifier for the chat (chat_id)"

    hashed_user_id:
      type: string
      note: "[Hashed] Backend hashes the user's actual ID before storing/querying"

    encrypted_title:
      type: text # Suitable for potentially longer titles
      note: "[Encrypted] User-defined title of the chat, encrypted using the key from Vault"

    messages_v:
      type: integer
      note: "Version number for messages, increments when a new message is added"

    title_v:
      type: integer
      note: "Version number for the title, increments when the title is updated"

    last_edited_overall_timestamp:
      type: integer
      note: "Unix timestamp (seconds) of the most recent modification to messages or draft (not title). Used for sorting chats by recency."

    unread_count:
      type: integer
      note: "Number of unread messages in this chat for the user"

    created_at:
      type: integer
      note: "Unix timestamp (seconds) when the chat was first initiated, e.g., first draft saved"

    updated_at:
      type: integer
      note: "Unix timestamp (seconds) of the last update to metadata, draft, or addition of a message"

    last_message_timestamp:
      type: integer
      note: "Unix timestamp (seconds) of the most recent completed message, for sorting"

    encrypted_active_focus_id:
      type: string
      note: "[Encrypted] ID of the currently active focus for this chat (e.g., 'travel/plan_trip'). Encrypted with chat-specific key."

    encrypted_chat_summary:
      type: text
      note: "[Encrypted] Chat summary (2-3 sentences) generated during post-processing, encrypted using chat-specific key"

    encrypted_chat_tags:
      type: text
      note: "[Encrypted] Array of max 10 tags for categorizing the chat, encrypted as base64 string using chat-specific key. Must be TEXT not JSON since it's encrypted."

    encrypted_follow_up_request_suggestions:
      type: text
      note: "[Encrypted] Array of 6 follow-up request suggestions for the current chat, encrypted as base64 string using chat-specific key. Must be TEXT not JSON since it's encrypted."

    encrypted_chat_key:
      type: string
      length: 512
      note: "[Encrypted] Chat-specific encryption key, encrypted with user's master key for device sync"

    encrypted_icon:
      type: string
      note: "[Encrypted] Icon name from Lucide library, generated during pre-processing, encrypted using chat-specific key"

    encrypted_category:
      type: string
      note: "[Encrypted] Category name, generated during pre-processing, encrypted using chat-specific key"

    shared_with_user_hashes:
      type: json
      note: "Array of SHA-256 hashes of users allowed to access this chat. Initially contains hash(email) for lookup, which is upgraded to hash(user_id) after first access to allow access even after email changes. Format: ['hash1', 'hash2', ...]. Uses SHA256(user_id.encode()).hexdigest() for user_id hashing to match system convention."

    shared_public:
      type: boolean
      note: "Whether this chat is publicly shared. If true, anyone with the link can access it (subject to encryption key in URL fragment)."

    shared_timestamp:
      type: integer
      note: "Unix timestamp (seconds) marking the point up to which shared messages can be read by others. Messages with timestamps <= this value are visible to users with access. Null if chat is not shared. Updated when sharing is enabled or when the owner wants to limit message visibility to shared users."

# TODO: Create separate model for new_chat_request_suggestions
# According to message_processing.md, new_chat_request_suggestions should be stored separately
# (50 most recent suggestions stored in IndexedDB under separate key, not per chat)
# This will require a new collection: new_chat_suggestions with fields like:
# - id, hashed_user_id, encrypted_suggestion_text, created_at, updated_at
