# Embeds Architecture

> Embeds are separate entities from messages, stored independently and referenced in messages via lightweight JSON/YAML blocks. This enables independent updates, cross-chat references, and efficient handling of long-running tasks. All sensitive fields (type, chat_id, message_id, task_id) are protected client-side before storage to maintain zero-knowledge architecture.

## Overview

Embeds replace the previous "contents" model and represent a first-class entity for storing structured content separately from messages. This architecture enables:

- **Independent Updates**: Update embed content without modifying the message (e.g., long-running tasks)
- **Cross-Chat References**: Link/mention embeds across different chats
- **Efficient Caching**: Server can cache embeds separately from messages for fast AI context building
- **Cleaner Messages**: Messages contain lightweight references instead of heavy embedded content
- **Zero-Knowledge**: Embeds are client-encrypted before storage, maintaining zero-knowledge architecture

## Architecture Principles

### Separation of Concerns

- **Messages**: Store markdown text with lightweight embed references
- **Embeds**: Store full structured content (skill results, code blocks, files, sheets, etc.)
- **References**: Messages reference embeds via JSON/YAML blocks in markdown

### Zero-Knowledge Architecture

- Embeds are encrypted client-side using embed-specific encryption keys (`embed_key`) independent of chats
- Server stores only `encrypted_content` (cannot decrypt)
- **Privacy Protection**: `chat_id`, `message_id`, `task_id`, and `embed_id` are hashed client-side (SHA256) before sending to server - one-way hashing prevents server from linking embeds to chats/messages
- **Type Privacy**: `type` is encrypted client-side - server cannot determine embed type without decryption key
- Server cache uses vault encryption for AI processing (server can decrypt for context)
- Permanent storage in Directus is zero-knowledge (client-encrypted)
- **Independent Sharing**: Embeds can be shared independently of chats using shared encryption keys (stored in URL fragments, never sent to server)

### Wrapped Key Architecture (Offline-First Sharing)

To enable offline chat sharing while maintaining cross-chat embed usage, each embed's encryption key (`embed_key`) is stored in multiple wrapped forms in the `embed_keys` collection. This follows the same pattern as the master key with multiple login methods (see [Security Architecture](./security.md)).

**Key Wrapping Entries:**
- **Master Key Wrapper** (`key_type="master"`): `AES(embed_key, master_key)` - for owner's cross-chat access
- **Chat Key Wrapper** (`key_type="chat"`): `AES(embed_key, chat_key)` - one per chat the embed is referenced in

**Benefits:**
- **Offline Chat Sharing**: All wrapped keys are pre-stored on server, no request needed at share time
- **Cross-Chat References**: Owner can use master key to decrypt embed in any chat
- **Shared Chat Access**: Recipient uses chat key from share link to decrypt embedded content
- **Simple Addition**: When embed is copied to new chat, just INSERT new chat key wrapper (no read-modify-write)

### Dual Storage

- **Client-side**: EmbedStore (IndexedDB) for fast local access and rendering
- **Server-side**: Directus for permanent storage and cross-device sync
- **Server Cache**: Redis cache for last 3 chats' embeds (vault-encrypted for AI context)

## Embed Model Structure

### Directus Schema (Permanent Storage)

```yaml
# Directus schema for embeds collection
embeds:
  type: collection
  fields:
    id:
      type: uuid
      note: "Primary Key - Unique identifier for the embed, auto-generated by Directus."
    
    embed_id:
      type: string
      note: "[Indexed] Unique identifier for the embed. Format: UUID v4. Generated by the client."
      options:
        unique: true
    
    hashed_chat_id:
      type: string
      note: "[Indexed] SHA256 hash of chat_id (for linking without exposing actual chat_id, protects privacy). Client-side hashed before sending to server."
    
    hashed_message_id:
      type: string
      note: "[Indexed] SHA256 hash of message_id (for linking without exposing actual message_id, protects privacy). Client-side hashed before sending to server. Can be null if referenced by multiple messages."
    
    hashed_task_id:
      type: string
      note: "[Optional] SHA256 hash of task_id (for long-running tasks, protects privacy). Used to update embed when task completes. Client-side hashed before sending to server."
    
    encrypted_type:
      type: string
      note: "[Encrypted] Type of embed encrypted client-side (app_skill_use, website, place, event, code, file, sheet, document, etc.). Server cannot determine embed type without decryption key. Encrypted with same key as encrypted_content."
    
    status:
      type: string
      note: "Status of embed: 'processing' | 'finished' | 'error'"
    
    hashed_user_id:
      type: string
      note: "[Indexed] Hashed user ID of embed owner"
    
    # NOTE: encryption_key_embed moved to embed_keys collection
    # This allows multiple wrapped versions (master key + per-chat keys) for offline sharing
    # See embed_keys schema below
    
    share_mode:
      type: string
      note: "[Indexed] Sharing mode: 'private' | 'shared_with_user' | 'public'. Default: 'private'"
      default: "private"
    
    shared_with_users:
      type: json
      note: "[Optional] Array of hashed_user_ids who have access (for user-specific sharing)"
    
    embed_ids:
      type: json
      note: "[Optional] Array of embed IDs for composite app_skill_use embeds (e.g., web search contains embed_ids pointing to website embeds). Null for single embeds or non-app_skill_use embeds."
    
    encrypted_content:
      type: textfield
      note: "[Encrypted] Full embed content (TOON/JSON format). For app_skill_use embeds with composite results, contains query, provider, skill name, and metadata. For single embeds (code, file, sheet, document, website, place, event), contains the actual content. Encrypted with encryption_key_embed (private) or shared_encryption_key (shared)"
    
    encrypted_text_preview:
      type: textfield
      note: "[Encrypted] Lightweight text preview for text-based embeds (code, documents). Always synced to client for fast rendering. Encrypted with same key as encrypted_content."
    
    parent_embed_id:
      type: string
      note: "[Optional] For versioned embeds: references the parent embed_id this version is based on"
    
    version_number:
      type: integer
      note: "[Optional] Version number for this embed (starts at 1, increments on updates)"
    
    encrypted_diff:
      type: textfield
      note: "[Encrypted] For file updates: stores diff/patch between versions (unified diff format). Encrypted with same key as encrypted_content."
    
    file_path:
      type: string
      note: "[Optional] For code/file embeds: relative file path for detecting updates to same file"
    
    content_hash:
      type: string
      note: "[Indexed] SHA256 hash of embed content. Used for duplicate detection (file, code, sheet, document) and change detection (versioning). Not used for website, place, event, or app_skill_use embeds."

    text_length_chars:
      type: integer
      note: "Character count of text-based embed content (code, table, document, app_skill_use TOON output). For app_skill_use, counts cleartext TOON characters. Used by LLM to decide when to reload full embed after chat compression. Null for non-text embeds (website, place, event without substantial text)."

    created_at:
      type: integer
      note: "Unix timestamp (seconds) when the embed was created. Provided by the application."

    updated_at:
      type: integer
      note: "Unix timestamp (seconds) when the embed was last updated. Used for task completion updates and versioning."
```

### Directus Schema: embed_keys (Key Wrappers)

The `embed_keys` collection stores multiple wrapped versions of each embed's encryption key, enabling both owner cross-chat access and offline-first shared chat access:

```yaml
# Directus schema for embed_keys collection
embed_keys:
  type: collection
  fields:
    id:
      type: uuid
      note: "Primary Key - auto-generated by Directus"
    
    hashed_embed_id:
      type: string
      note: "[Indexed] SHA256 hash of embed_id. References the embed this key belongs to. Hashed for privacy."
    
    key_type:
      type: string
      note: "[Indexed] Type of key wrapper: 'master' (wrapped with user's master key) or 'chat' (wrapped with chat's encryption key)"
    
    hashed_chat_id:
      type: string
      note: "[Indexed, Nullable] For key_type='chat': SHA256(chat_id) indicating which chat's key was used to wrap. Null for key_type='master'."
    
    encrypted_embed_key:
      type: string
      note: "The embed's encryption key wrapped with the appropriate key. For key_type='master': AES(embed_key, master_key). For key_type='chat': AES(embed_key, chat_key)."
    
    hashed_user_id:
      type: string
      note: "[Indexed] Hashed user ID of embed owner (for access control and queries)"
    
    created_at:
      type: integer
      note: "Unix timestamp (seconds) when this key entry was created"
```

**Key Entry Types:**

| key_type | encrypted_embed_key | Use Case |
|----------|---------------------|----------|
| `master` | `AES(embed_key, master_key)` | Owner access across all chats |
| `chat` | `AES(embed_key, chat_key)` | Shared chat recipient access |

### Client-Side EmbedStore (IndexedDB)

Embeds are also stored in the client-side EmbedStore for fast local access. **IMPORTANT**: All content in IndexedDB is stored **encrypted** - plaintext is never stored client-side.

```typescript
interface EmbedStoreEntry {
  embed_id: string;
  type: EmbedType; // Decrypted type (client-side only, never sent to server in plaintext)
  status: 'processing' | 'finished' | 'error';
  encrypted_content: string; // CLIENT-ENCRYPTED TOON-encoded string (encrypted with master key)
  // CRITICAL: Content is ALWAYS stored encrypted in IndexedDB
  // Server sends plaintext TOON → Client encrypts immediately → Stores encrypted
  // Decrypted on-demand when needed for rendering or inference
  // TOON format reduces storage by 30-60% compared to JSON while preserving all data
  encrypted_text_preview?: string; // CLIENT-ENCRYPTED lightweight text preview (for text-based embeds)
  task_id?: string; // Plaintext task_id (client-side only, hashed before sending to server)
  chat_id?: string; // Plaintext chat_id (client-side only, hashed before sending to server)
  message_id?: string; // Plaintext message_id (client-side only, hashed before sending to server)
  parent_embed_id?: string; // For versioned embeds
  version_number?: number;
  encrypted_diff?: string; // CLIENT-ENCRYPTED unified diff for file updates
  file_path?: string; // For detecting file updates
  content_hash?: string; // SHA256 hash for deduplication
  text_length_chars?: number; // Character count for text-based embeds (LLM compression decision)
  share_mode: 'private' | 'shared_with_user' | 'public';
  createdAt: number;
  updatedAt: number;
}
```

**Content Format (TOON)**:
- Embed content is stored in **TOON (Token-Oriented Object Notation) format** as a string
- TOON reduces storage size by 30-60% compared to JSON while preserving all data
- Content is decoded from TOON only when needed:
  - **Rendering**: Decode TOON to display embed preview in UI
  - **Inference**: Decode TOON when building AI context (server-side)
  - **Storage**: Keep as TOON string (no conversion needed)
- This approach combines the benefits of:
  - **Separate embed entities** (independent updates, cross-chat references)
  - **Space-efficient storage** (TOON format saves 30-60% vs JSON)
  - **No repeated conversion** (store once as TOON, decode when needed)

### Server-Side Cache (Redis)

Embeds are cached server-side for fast AI context building:

- **Cache Key**: `embed:{embed_id}` (global cache, one entry per embed regardless of how many chats reference it)
- **Encryption**: Vault-encrypted with `encryption_key_user_server` (server can decrypt for AI)
- **Content Format**: TOON-encoded string (same as stored in Directus/IndexedDB)
- **TTL**: 24 hours (same as message cache)
- **Purpose**: Fast embed resolution when building AI context from cached chat history
- **Chat Index**: `chat:{chat_id}:embed_ids` (Redis Set tracking which embed_ids belong to each chat, used for eviction)
- **Access Control**: When loading from cache, verify `hashed_user_id` matches requesting user (for private embeds) or check `share_mode` and `shared_with_users` (for shared embeds)
- **Decoding**: TOON content is decoded only when building AI context for inference (not on every cache read)

## Embed Reference Format in Messages

Embeds are referenced in messages (both user and assistant) via **JSON code blocks** in markdown. This allows flexible placement anywhere in the response and enables streaming embed references as chunks.

### Format

**Basic Reference** (all details stored in embed entry):
```markdown
```json
{
  "type": "app_skill_use",
  "embed_id": "550e8400-e29b-41d4-a716-446655440000"
}
```
```

**Versioned Reference** (for referencing files at specific points in time):
```markdown
```json
{
  "type": "code",
  "embed_id": "550e8400-e29b-41d4-a716-446655440000",
  "version": 3
}
```
```

If `version` is omitted, references the latest version.

**Key Principles**:
- Message references are minimal - only `type` and `embed_id`
- All content (title, description, query, results, metadata) is stored in the embed entry itself (as TOON string)
- Embed references can be placed anywhere in the message (not just prepended)
- Embed references are streamed as chunks during assistant response generation
- Frontend parses JSON code blocks to detect and resolve embed references

### Embed Types

**App Skill Executions**:
- **`app_skill_use`**: App skill execution results (e.g., web search, places search, events search, code generation, image generation). For composite results (web search, places, events), contains query, provider, metadata, and `embed_ids` array pointing to child embeds.

**Result Embeds** (child embeds for composite app skill results):
- **`website`**: Individual website from web search results (one embed per website)
- **`place`**: Individual place from location search (one embed per place)
- **`event`**: Individual event from event search (one embed per event)

**Content Embeds** (supports duplicate detection):
- **`file`**: Uploaded files (images, documents, etc.)
- **`code`**: Code blocks generated by LLM or pasted by user
- **`sheet`**: Tables/spreadsheets generated by LLM or pasted by user
- **`document`**: Rich text documents

### Composite Embeds Structure

Some app skills return multiple results. The structure uses a parent `app_skill_use` embed entry that contains metadata and references to child embed entries.

#### Key Inheritance for Nested Embeds

**Important**: Child embeds automatically inherit the parent's `embed_key` for encryption and decryption. This means:
- The parent embed has a unique encryption key (`embed_key`) generated when the embed is created
- The parent embed's key is wrapped in `embed_keys` collection (master + chat wrappers) - **ONLY for parent embeds**
- Child embeds reference the parent via `parent_embed_id` field (set by backend when child embeds are created)
- Child embeds are **encrypted with the parent's `embed_key`** (not their own key)
- Child embeds **do NOT have their own `embed_keys` entries** (no key wrappers for children)
- When decrypting child embeds, the client uses the parent's unwrapped key (via `parent_embed_id` lookup)
- **Benefit**: Single key unwrap operation unlocks entire result set (80% fewer cryptographic operations vs independent keys)
- **Sharing**: When sharing a child embed, the parent's key is used in the share link (since child has no separate key)

**Web Search Example**:
- Message reference (minimal):
  ```json
  {
    "type": "app_skill_use",
    "embed_id": "550e8400-e29b-41d4-a716-446655440000"
  }
  ```
- Parent embed entry (`embed_id: 550e8400...`, type: `app_skill_use`):
  - `encrypted_content`: Contains query, provider, skill name, and other search metadata
  - `encrypted_content` encrypted with `embed_key_parent`
  - `embed_ids`: Array of embed IDs pointing to individual website embeds
    - `["660e8400-...", "770e8400-...", "880e8400-..."]`
  - `parent_embed_id`: null (this is the root)
- Child embed entries (individual websites):
  - Each has `type: "website"` and `parent_embed_id: "550e8400..."` (set by backend)
  - Contains website-specific content (title, URL, description, snippets, etc.)
  - `encrypted_content` encrypted with parent's `embed_key` (inherited from parent - Option A)
  - **No `embed_keys` entries** for child embeds (only parent has key wrappers)
  - Frontend uses `parent_embed_id` to look up parent's key for decryption

**Places/Events Search**: Same structure - parent `app_skill_use` embed contains query/metadata and `embed_ids` array pointing to individual `place`/`event` embeds. All children use parent's key.

**Single Result Skills** (e.g., code generation, image generation):
- Message reference:
  ```json
  {
    "type": "app_skill_use",
    "embed_id": "550e8400-e29b-41d4-a716-446655440000"
  }
  ```
- Embed entry (type: `app_skill_use`):
  - `encrypted_content`: Contains skill result (code, image metadata, etc.)
  - `embed_ids`: null (single result, no child embeds)
  - `parent_embed_id`: null (standalone embed)

### Example in Message Markdown

```markdown
I found some information about egg prices:

```json
{
  "type": "app_skill_use",
  "embed_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

The search results show that egg prices have increased significantly since 2023.
```

The embed entry (`embed_id: 550e8400...`, type: `app_skill_use`) contains:
- `encrypted_content`: Query, provider, skill name, and other search metadata
- `embed_ids`: `["660e8400-...", "770e8400-...", "880e8400-..."]` (array of website embed IDs)

Each website embed (referenced in `embed_ids`, type: `website`) contains:
- `encrypted_content`: Title, URL, description, snippets, etc.

## Embed Lifecycle

### 1. Creation

**App Skill Execution** (Server-Side, Immediate):
1. Skill executes and returns results (JSON format)
2. **Immediately after skill execution** (before LLM inference continues):
   - **For composite results** (web search, places, events):
     - Convert each result to TOON format (plaintext)
     - Create child embed entries (one per result): `website`, `place`, or `event` embeds
       - Each child embed: `content` field contains TOON-encoded result data (plaintext)
     - Create parent embed entry: `app_skill_use` embed
       - Parent embed `content`: TOON-encoded metadata (query, provider, skill name, etc.) (plaintext)
       - Parent embed `embed_ids`: Array of child embed IDs
   - **For single results** (code generation, image generation):
     - Convert result to TOON format (plaintext)
     - Create single `app_skill_use` embed entry
     - Embed `content`: TOON-encoded result data (plaintext)
     - Check for duplicates using `content_hash` (if applicable)
     - `embed_ids`: null (no child embeds)
3. **Dual Encryption - Server-Side Caching**:
   - Encrypt embeds with vault key (`encryption_key_user_server`) for AI inference cache
   - Cache at `embed:{embed_id}` (24h TTL, global cache)
   - Add to `chat:{chat_id}:embed_ids` index for eviction
   - Content stored as vault-encrypted TOON string (server can decrypt for AI context)
4. **Send Plaintext TOON to Client via WebSocket**:
   - Send `send_embed_data` WebSocket event with PLAINTEXT TOON content
   - Payload: `embed_id`, `type` (plaintext), `content` (plaintext TOON), `text_preview`, `status`, metadata
   - Client receives plaintext TOON (server vault encryption is separate, client cannot decrypt vault-encrypted data)
   - **CRITICAL**: Client receives plaintext, NEVER stores plaintext - encrypts immediately before storage
5. **Stream Embed Reference Chunk**:
   - Create embed reference JSON: `{"type": "app_skill_use", "embed_id": "..."}`
   - Stream as markdown code block chunk to frontend immediately
   - Frontend receives chunk, parses embed reference, waits for `send_embed_data` event
   - Frontend renders embed preview immediately when data arrives (user sees results!)
6. **LLM Inference Continues**:
   - LLM receives filtered skill results (for inference efficiency)
   - LLM processes results and generates response
   - LLM can place additional embed references anywhere in response (flexible placement)
7. **Client-Side Encryption and Storage**:
   - Client receives plaintext TOON via `send_embed_data` WebSocket event
   - **NEVER stores plaintext** - encrypts immediately before any storage
   - **Client-Side Privacy Protection**:
     - Hash `chat_id`, `message_id`, `task_id`, `embed_id` using SHA256 (one-way, protects privacy)
     - **Determine encryption key**:
       - **Parent embeds**: Generate unique `embed_key` (random 256-bit key) - generated early when "processing" status is received
       - **Child embeds**: Use parent's `embed_key` (key inheritance) - parent key must be available (cached from "processing" phase)
     - Encrypt `type` with `embed_key` (server cannot determine embed type)
     - Encrypt `content` (TOON string) with `embed_key`
     - Encrypt `text_preview` with same `embed_key`
     - Encrypt `diff` with same `embed_key` (for versioned embeds)
   - **Create Key Wrappers** (for offline sharing support - **ONLY for parent embeds**):
     - **Parent embeds only**: Create key wrappers for parent's `embed_key`
       - Master key wrapper: `AES(embed_key, master_key)` with `key_type="master"`
       - Chat key wrapper: `AES(embed_key, chat_key)` with `key_type="chat"` and `hashed_chat_id`
       - Both wrappers stored in `embed_keys` collection with `hashed_embed_id`
     - **Child embeds**: Do NOT create key wrappers (they use parent's key, no separate keys)
   - Store encrypted embeds in EmbedStore (IndexedDB) - **all content encrypted**
   - Send client-encrypted embeds to server via `store_embed` WebSocket event for Directus storage
   - Send key wrappers to server via `store_embed_keys` WebSocket event for `embed_keys` collection
8. **Server Permanent Storage (Zero-Knowledge)**:
   - Server receives client-encrypted embeds via `store_embed` WebSocket event
   - Server stores client-encrypted embeds in Directus (cannot decrypt - zero-knowledge)
   - Embeds stored with hashed IDs and encrypted type
   - Content remains as client-encrypted TOON string (efficient storage)

**Long-Running Tasks**:
1. Skill execution starts, returns `task_id` immediately
2. Client creates embed with `status: "processing"` and `task_id`
3. LLM sees embed reference and responds: "I started the task, I'll update you when ready"
4. When task completes, WebSocket event with `task_id` triggers embed update
5. Client updates embed content, changes `status: "finished"`
6. Frontend automatically updates embed preview

### 2. Update

**Task Completion**:
- WebSocket event: `embed_update` with `task_id` (hashed) and new content
- Client hashes `task_id` and queries embed by `hashed_task_id`
- Client updates embed in EmbedStore
- Client sends updated embed to server (encrypted, with hashed IDs)
- Server updates embed in Directus (using hashed_task_id for lookup)
- Server updates embed in cache: `embed:{embed_id}` (global cache, available to all chats that reference it)
- Frontend re-renders embed preview automatically

### 3. Resolution (Rendering)

**Client-Side Rendering**:
1. Parse message markdown
2. Detect embed reference JSON blocks
3. Load embed from EmbedStore (IndexedDB)
4. If missing, fetch from Directus (decrypt client-side)
   - Decrypt `encrypted_type` to determine embed type
   - Decrypt `encrypted_content` to get embed content
5. Render embed preview based on decrypted type

**Server-Side Context Building**:
1. Parse message markdown from cache
2. Detect embed reference JSON blocks
3. Load embeds from cache (`embed:{embed_id}` for each embed_id, verify access control)
4. Replace embed references with actual content (TOON format)
5. Include in AI context for processing

## Auto-Conversion of LLM-Generated Content

### Decision: Client-Side Conversion

**Question**: Should we auto-convert LLM-generated code blocks and tables to embeds?

**Answer**: Yes, but with important considerations:

### Implementation Approach

**When to Convert**:
- **Code blocks**: Always convert (reduces message size, enables independent updates)
- **Sheets/Tables**: Always convert (sheets can be large, benefit from embed structure)
- **App skill results**: Already embeds (no conversion needed)

**Where to Convert**:
- **Client-side**: Parse assistant response markdown, detect code blocks/sheets
- **Before encryption**: Convert to embeds, create embed entries
- **Replace in message**: Replace code block/sheet content with embed reference JSON

**Server Cache Consideration**:
- Server cache stores messages with embed references (not full content)
- When building AI context, server resolves embeds from cache (`embed:{embed_id}`)
- If embed missing from cache, server requests from client (fallback)
- This ensures server cache remains efficient while supporting auto-conversion

### Conversion Flow

1. **Assistant Response Received**:
   - Client receives markdown response from server
   - Parse markdown to detect code blocks and sheets
   - For each code block/sheet:
     - Generate `embed_id` (UUID)
     - Create embed entry in EmbedStore
     - Encrypt embed content
     - Send embed to server for Directus storage
     - Replace code block/sheet in markdown with embed reference JSON

2. **Message Storage**:
   - Store message with embed references (not full content)
   - Message is smaller and cleaner
   - Embeds stored separately

3. **Rendering**:
   - Parse message markdown
   - Detect embed references
   - Load embeds from EmbedStore
   - Render embed previews

## Embed Resolution for AI Context

### Server-Side Resolution

When building AI context from cached chat history, the server must resolve embed references:

1. **Parse Message Markdown**:
   - Extract embed reference JSON blocks
   - Identify `embed_id` values

2. **Load Embeds from Cache**:
   - Check `embed:{embed_id}` cache for each embed_id
   - Verify access control (check `hashed_user_id` for private embeds, or `share_mode`/`shared_with_users` for shared embeds)
   - Load embeds by `embed_id`
   - Decrypt using vault key (server can decrypt)

3. **Replace References with Content**:
   - Replace embed reference JSON blocks with actual embed content (TOON format)
   - Include in message history for AI processing

4. **Fallback if Missing**:
   - If embed not in cache, request from client
   - Client loads from Directus, decrypts, sends to server
   - Server caches embed for future use

### Client-Side Resolution (Older Chats)

For chats not in server cache (older than last 3):

1. **Client Loads Chat**:
   - Load messages from Directus (encrypted)
   - Decrypt messages client-side

2. **Parse and Resolve**:
   - Parse message markdown
   - Detect embed references
   - Load embeds from Directus (encrypted)
   - Decrypt embeds client-side
   - Render embed previews

3. **Send to Server**:
   - When user sends follow-up message
   - Client sends decrypted message history with resolved embeds
   - Server caches for future use

## Long-Running Tasks

### Problem

Some app skills take seconds or minutes to complete (e.g., image generation, video processing, web scraping). The LLM needs to respond immediately while the task runs in the background.

### Solution

1. **Immediate Response**:
   - Skill execution starts, returns `task_id`
   - Client creates embed with `status: "processing"` and `task_id`
   - Message references embed immediately
   - LLM sees embed reference and responds: "I started the task, I'll let you know when it's ready"

2. **Task Completion**:
   - Task completes, WebSocket event sent: `embed_update`
   - Event includes `hashed_task_id` (SHA256 hash) and completed embed content
   - Client hashes `task_id` and queries embed by `hashed_task_id`
   - Client updates embed: `status: "finished"`, new content
   - Client sends updated embed to server (encrypted, with hashed IDs)
   - Server updates embed in Directus (using hashed_task_id for lookup)
   - Frontend automatically updates embed preview
   - User sees updated results without new message

### WebSocket Event Format

```json
{
  "event": "embed_update",
  "payload": {
    "hashed_task_id": "a1b2c3d4...", // SHA256 hash of task_id (privacy protection)
    "embed_id": "550e8400-e29b-41d4-a716-446655440000",
    "status": "finished",
    "encrypted_content": "...", // Client-encrypted embed content
    "hashed_chat_id": "e5f6g7h8...", // SHA256 hash of chat_id (privacy protection)
    "hashed_message_id": "i9j0k1l2..." // SHA256 hash of message_id (privacy protection)
  }
}
```

## WebSocket Events for Embed Transfer

All embed data transfer happens via WebSocket (not HTTP) to maintain real-time synchronization and zero-knowledge architecture.

### `send_embed_data` (Server → Client)

**Purpose**: Send plaintext TOON embed content to client for encryption and storage.

**When**: Immediately after embed creation (skill execution) or when client requests embed data.

**Direction**: Server → Client

**Payload**:
```json
{
  "event": "send_embed_data",
  "payload": {
    "embed_id": "550e8400-e29b-41d4-a716-446655440000",
    "type": "app_skill_use", // Plaintext type (client will encrypt before storage)
    "content": "...", // Plaintext TOON-encoded string (client will encrypt before storage)
    "text_preview": "...", // Plaintext text preview (client will encrypt before storage)
    "status": "finished",
    "chat_id": "abc123...", // Plaintext chat_id (client will hash before sending to server)
    "message_id": "def456...", // Plaintext message_id (client will hash before sending to server)
    "task_id": "ghi789...", // Optional, for long-running tasks (client will hash)
    "embed_ids": ["child1", "child2"], // For composite embeds (app_skill_use)
    "parent_embed_id": null, // For versioned embeds
    "version_number": 1,
    "file_path": null, // For code/file embeds
    "content_hash": "sha256...", // For deduplication
    "text_length_chars": 1234, // Character count for text-based embeds (LLM compression decision)
    "share_mode": "private",
    "createdAt": 1234567890,
    "updatedAt": 1234567890
  }
}
```

**Client Behavior**:
1. Receive plaintext TOON content
2. **IMMEDIATELY encrypt** before any storage (NEVER store plaintext)
3. Encrypt `type`, `content`, `text_preview` with master key
4. Hash `chat_id`, `message_id`, `task_id` with SHA256
5. Store encrypted embed in IndexedDB
6. Send encrypted embed to server via `store_embed` event

### `store_embed` (Client → Server)

**Purpose**: Client sends encrypted embed to server for permanent Directus storage (zero-knowledge).

**When**: After client receives plaintext TOON, encrypts it, and stores in IndexedDB.

**Direction**: Client → Server

**Payload**:
```json
{
  "event": "store_embed",
  "payload": {
    "embed_id": "550e8400-e29b-41d4-a716-446655440000",
    "encrypted_type": "...", // CLIENT-ENCRYPTED type (server cannot decrypt)
    "encrypted_content": "...", // CLIENT-ENCRYPTED TOON string (server cannot decrypt)
    "encrypted_text_preview": "...", // CLIENT-ENCRYPTED text preview (server cannot decrypt)
    "status": "finished",
    "hashed_chat_id": "sha256...", // SHA256 hash of chat_id (privacy protection)
    "hashed_message_id": "sha256...", // SHA256 hash of message_id (privacy protection)
    "hashed_task_id": "sha256...", // Optional, SHA256 hash of task_id
    "hashed_user_id": "sha256...", // SHA256 hash of user_id
    "embed_ids": ["child1", "child2"], // For composite embeds
    "parent_embed_id": null,
    "version_number": 1,
    "encrypted_diff": "...", // CLIENT-ENCRYPTED diff for versioned embeds
    "file_path": null,
    "content_hash": "sha256...",
    "text_length_chars": 1234, // Character count for text-based embeds (LLM compression decision)
    "share_mode": "private",
    "shared_with_users": [],
    "createdAt": 1234567890,
    "updatedAt": 1234567890
  }
}
```

**Server Behavior**:
1. Receive client-encrypted embed
2. Store in Directus as-is (cannot decrypt - zero-knowledge)
3. Server can only see: `embed_id`, `status`, hashed IDs, `share_mode`, timestamps
4. Server CANNOT see: actual type, content, preview (all encrypted)

### `store_embed_keys` (Client → Server)

**Purpose**: Client sends wrapped embed keys to server for permanent storage, enabling offline sharing and cross-chat access.

**When**: After client creates an embed or adds an embed to a new chat.

**Direction**: Client → Server

**Payload**:
```json
{
  "event": "store_embed_keys",
  "payload": {
    "keys": [
      {
        "hashed_embed_id": "sha256...", // SHA256 hash of embed_id
        "key_type": "master", // 'master' or 'chat'
        "hashed_chat_id": null, // For key_type='chat': SHA256(chat_id)
        "encrypted_embed_key": "...", // AES(embed_key, master_key) or AES(embed_key, chat_key)
        "hashed_user_id": "sha256...",
        "created_at": 1234567890
      },
      {
        "hashed_embed_id": "sha256...",
        "key_type": "chat",
        "hashed_chat_id": "sha256...",
        "encrypted_embed_key": "...",
        "hashed_user_id": "sha256...",
        "created_at": 1234567890
      }
    ]
  }
}
```

**Server Behavior**:
1. Receive wrapped keys
2. Store in `embed_keys` collection (cannot decrypt - zero-knowledge)
3. Server can only see: hashed IDs, key_type, timestamps
4. Server CANNOT see: actual embed_key (encrypted)

### `request_embed` (Client → Server)

**Purpose**: Client requests embed data when embed reference is detected but data not in IndexedDB.

**When**: Message parsing detects embed reference, but embed not found in IndexedDB.

**Direction**: Client → Server

**Payload**:
```json
{
  "event": "request_embed",
  "payload": {
    "embed_id": "550e8400-e29b-41d4-a716-446655440000"
  }
}
```

**Server Behavior**:
1. Check embed in cache (`embed:{embed_id}`)
2. If found: Decrypt with vault key, send via `send_embed_data` (plaintext TOON)
3. If not in cache: Load from Directus (client-encrypted), cannot decrypt
   - Return error: "Embed not in cache, client must decrypt from Directus"
4. Client falls back to loading from Directus directly

### `embed_update` (Server → Client)

**Purpose**: Notify client when embed status changes (task completion, error).

**When**: Long-running task completes or embed is updated.

**Direction**: Server → Client

**Payload**:
```json
{
  "event": "embed_update",
  "payload": {
    "embed_id": "550e8400-e29b-41d4-a716-446655440000",
    "chat_id": "abc123...", // Plaintext chat_id
    "message_id": "def456...", // Plaintext message_id
    "status": "finished" | "error",
    "task_id": "ghi789...", // Optional, for long-running tasks
    "child_embed_ids": ["child1", "child2"] // For composite embeds
  }
}
```

**Client Behavior**:
1. Receive status update
2. Request full embed data via `request_embed` if not in cache
3. Update embed in IndexedDB
4. Re-render embed preview in UI

### Dual Encryption Flow Summary

**Server Side (after skill execution)**:
```
Plaintext TOON → Vault-encrypt → Cache (AI can use)
              ↓
              Send plaintext TOON to client via send_embed_data
```

**Client Side**:
```
Receive plaintext TOON → Encrypt with master key → IndexedDB (encrypted!)
                       ↓
                       Send encrypted to server via store_embed
```

**Server Side (receives encrypted from client)**:
```
Receive client-encrypted → Store in Directus (cannot decrypt, zero-knowledge)
```

**Key Principles**:
- **Vault Encryption**: Server-only, for AI inference cache (server can decrypt)
- **Client Encryption**: Client-only, for zero-knowledge storage (server cannot decrypt)
- **Plaintext Transfer**: Server → Client via WebSocket (encrypted in transit via TLS)
- **Never Store Plaintext**: Client encrypts immediately before IndexedDB storage
- **Two Separate Keys**: Vault key (server) vs Master key (client) - completely independent

## Cross-Chat References

Embeds can be referenced in multiple messages or even different chats:

### Use Cases

- **Copy/Paste**: User copies an embed from one chat to another
- **Mention**: User references a previous search result in a new chat
- **Link**: User shares an embed with another user (future feature)

### Implementation

- Embed `hashed_chat_id` points to the chat where it was created (can be null for shared embeds)
- Embed can be referenced in any message (same or different chat)
- Frontend resolves embed from EmbedStore or Directus
- Server cache includes embeds for all referenced chats (if in last 3)
- **Same User Cross-Chat**: Uses `embed_key` (decrypted from master key via `embed_keys` entry with `key_type="master"`) - no re-encryption needed

### Adding Embed to New Chat

When an embed is copied/referenced in a new chat:

1. Client decrypts `embed_key` using master key (from `key_type="master"` entry)
2. Client encrypts `embed_key` with new chat's key: `AES(embed_key, new_chat_key)`
3. Client creates new `embed_keys` entry with `key_type="chat"` and `hashed_chat_id` of new chat
4. Client sends new key entry to server (simple INSERT, no read-modify-write needed)

**Result**: Embed content remains unchanged, but now the embed can be decrypted by anyone who has the new chat's encryption key (e.g., shared chat recipients).

## Independent Embed Sharing

Embeds can be shared independently of chats, following the same zero-knowledge architecture as chat sharing. See [Share Chat Architecture](./share_chat.md) for the underlying principles.

### Sharing Modes

**Private** (default):
- Encrypted with `embed_key` (decrypted via master key from `embed_keys` entry)
- Accessible in any chat owned by the user (cross-chat references)
- Accessible in shared chats (via chat key wrapped `embed_key`)

**Shared with User**:
- `embed_key` included in encrypted share link blob
- Access tied to recipient's account
- Recipient receives notification with secure link

**Public**:
- `embed_key` included in encrypted share link blob
- Anyone with link can access (no user verification)
- Key stored in URL fragment (never sent to server)
- **Password Protection (Optional):** Users can optionally set a password when sharing an embed. The password is used to derive an additional encryption key that protects the embed_key in the URL fragment, providing an extra layer of security. The server has no knowledge of whether an embed is password-protected (true zero-knowledge).

### Sharing Flow

**Access Flow** (when someone opens a shared embed link):
1. Client extracts `embed_id` and `key` from URL fragment: `/#embed-id={embed_id}&key={encrypted_blob}`
2. Client sends request to server with `embed_id` (key blob stays in fragment, never sent to server)
3. Server checks:
   - Does embed exist?
   - If `share_mode === 'public'`: Return encrypted content
   - If `share_mode === 'shared_with_user'`: Check if user's `hashed_user_id` is in `shared_with_users` array
     - If yes: Return encrypted content
     - If no: Return error
   - If `share_mode === 'private'`: Return error
4. If access granted: Server returns encrypted content (server has no knowledge of password protection)
5. Client attempts to decrypt content using `shared_encryption_key` from URL fragment
6. **If decryption succeeds:** Content is displayed ✅
7. **If decryption fails:**
   - Client prompts user: "Unable to decrypt. If this share is password-protected, enter the password:"
   - User enters password (if applicable)
   - Client derives key from password (using deterministic salt or client-stored salt)
   - Client combines password-derived key with `shared_encryption_key` from URL fragment
   - Client attempts decryption again with combined key
   - If decryption succeeds: Content is displayed ✅
   - If decryption still fails: Show error: "Unable to decrypt. Please verify the link and password (if required)."
8. If access denied or embed doesn't exist: Show unified error message: "Embed can't be found. Either it doesn't exist or you don't have access to it."

**Share with User**:
1. User clicks "Share embed" on embed preview
2. Client generates `shared_encryption_key` (random, client-side)
3. **Password Protection (Optional):** If password is set:
   - User enters password when sharing
   - Client generates salt (deterministically from embed_id or stores in URL fragment/local storage)
   - Client derives key from password using PBKDF2 with the salt
   - Client combines password-derived key with `shared_encryption_key`
   - Client encrypts embed content with combined key
   - Salt is stored client-side (e.g., in URL fragment as `salt={salt}` or in local storage keyed by embed_id)
4. If no password: Client re-encrypts embed content with shared key only
5. Client sends encrypted embed + recipient's `hashed_user_id` to server (no password-related data)
6. Server stores encrypted embed with `share_mode: 'shared_with_user'` and adds recipient to `shared_with_users` array
7. Server sends notification to recipient with link: `/#embed-id={embed_id}&key={shared_encryption_key}` (and `salt={salt}` if password-protected)
8. Recipient's client attempts decryption with key from URL fragment, prompts for password if decryption fails

**Share Publicly**:
1. Similar flow, but `share_mode: 'public'`
2. Link format: `/#embed-id={embed_id}&key={shared_encryption_key}` (and `salt={salt}` if password-protected)
3. Anyone with link can access (no user verification needed)
4. Key and salt stored in URL fragment (never sent to server)
5. **Password Protection (Optional):** If password is set:
   - User enters password when sharing
   - Client generates salt (deterministically from embed_id or random, stored in URL fragment)
   - Client derives key from password using PBKDF2 with the salt
   - Client combines password-derived key with `shared_encryption_key`
   - Client encrypts embed content with combined key
   - Salt is included in URL fragment: `/#embed-id={embed_id}&key={shared_encryption_key}&salt={salt}`
   - Server stores only encrypted content (no password-related data)

**Cross-Chat Reference (Same User)**:
1. User references embed in different chat
2. Client uses `encryption_key_embed` (decrypted from master key)
3. No re-encryption needed (same user, same key)
4. Embed accessible across all user's chats

### Security Properties

**Zero-Knowledge Maintained**:
- Server never sees `shared_encryption_key` (URL fragment only)
- Server stores only encrypted content
- Client-side encryption/decryption only

**Access Control**:
- Private: Only accessible in original chat
- Shared with user: Access tied to recipient's account
- Public: Anyone with link (like chat sharing)

**Key Management**:
- `embed_key`: Per-embed encryption key, multiple wrapped versions stored in `embed_keys` collection
  - `key_type="master"`: `AES(embed_key, master_key)` for owner cross-chat access
  - `key_type="chat"`: `AES(embed_key, chat_key)` per chat for shared chat access
- **Independent embed sharing**: `embed_key` included in encrypted blob in URL fragment
- **Password-derived key (if password-protected):** Derived from password using PBKDF2, used to encrypt the `embed_key` in the URL fragment
- **Salt:** Stored in URL fragment, never on server
- Server never has decryption capability and has no knowledge of password protection

**Password Protection**:
- **Optional Feature:** Users can optionally set a password when sharing embeds
- **True Zero-Knowledge:** Server has no knowledge of whether an embed is password-protected
- **Password Derivation:** Password is combined with a salt and processed through PBKDF2 (100,000 iterations, SHA-256) to derive a 256-bit key
- **Salt Management:** Salt is generated client-side and stored in URL fragment (e.g., `salt={salt}`) or deterministically derived from embed_id. Never stored on server.
- **Key Combination:** Password-derived key is combined with `shared_encryption_key` using a key derivation function
- **Storage:** No password-related data is stored on the server (no hash, no salt, no indication of password protection)
- **Access Flow:** Client attempts decryption with `shared_encryption_key` first. If decryption fails, client prompts for password and tries again with combined key.
- **Security:** Even if someone obtains the `shared_encryption_key` from the URL, they cannot decrypt password-protected content without the password

### URL Fragment Pattern

Follows chat sharing pattern: `/#embed-id={embed_id}&key={encrypted_blob}` (optionally with password protection)
- Encrypted blob contains: `embed_key`, `generated_at`, `duration_seconds`, `pwd` flag
- Blob encrypted with key derived from embed_id: `KDF(embed_id) → derived_key`
- If password-protected (`pwd=1`): `embed_key` inside blob is also encrypted with password-derived key
- Key blob never sent to server (fragment only)
- Client stores `embed_key` after first access (removes from URL)
- Server checks `share_mode` and `shared_with_users` for access control
- No key verification needed - wrong key simply can't decrypt content
- Server has no knowledge of password protection (true zero-knowledge)

## File Versioning and Diff Storage

Embeds support efficient versioning for files (code, documents, sheets) by storing only diffs between versions, enabling:
- **Efficient Storage**: Only changes stored, not full content for each version
- **Time-Based References**: Reference files at specific points in time
- **Change History**: View how files evolved over time
- **Automatic Detection**: Auto-detect when same file is updated

### Version Structure

Each version is a separate embed entry with:
- `parent_embed_id`: References the previous version (null for version 1)
- `version_number`: Sequential version number (starts at 1)
- `file_path`: Relative file path for detecting updates to same file
- `encrypted_diff`: Unified diff format string (from parent to this version)
- `content_hash`: SHA256 hash of full content for deduplication

### Diff Storage Format

**Recommendation**: Single string (unified diff format) per version entry.

**Why Single String?**:
- Each embed entry = one version, so one diff per entry fits naturally
- Efficient storage: only changes stored, no duplication
- Simple queries: get version N by `embed_id` + `version_number`
- Chain reconstruction: start from v1, apply diffs sequentially
- Standard format: unified diff is widely supported

**Example Structure**:
```
Version 1 (embed_id: abc123): 
  - full content stored
  - no diff (original version)
  - version_number: 1
  - parent_embed_id: null

Version 2 (embed_id: def456): 
  - diff from v1→v2 (unified diff string)
  - version_number: 2
  - parent_embed_id: abc123

Version 3 (embed_id: ghi789): 
  - diff from v2→v3 (unified diff string)
  - version_number: 3
  - parent_embed_id: def456
```

### File Update Detection

When LLM generates or updates a code file:

1. **Detect Existing File**:
   - Check if embed with same `file_path` exists
   - Query: `SELECT * FROM embeds WHERE file_path = '{path}' AND hashed_user_id = '{user_id}' ORDER BY version_number DESC LIMIT 1`

2. **Compare Content**:
   - Calculate `content_hash` of new content
   - Compare with existing version's `content_hash`
   - If different: create new version

3. **Generate Diff**:
   - Compute unified diff from previous version to new version
   - Store diff in `encrypted_diff` field
   - Store full content in `encrypted_content` (for latest version)

4. **Create New Version**:
   - Generate new `embed_id` (UUID)
   - Set `parent_embed_id` to previous version's `embed_id`
   - Increment `version_number`
   - Store diff and metadata

### Referencing Files at Specific Points in Time

Messages can reference specific versions:

```json
{
  "type": "code",
  "embed_id": "550e8400-e29b-41d4-a716-446655440000",
  "version": 3
}
```

**Resolution**:
- If `version` specified: Query embed with `embed_id` + `version_number`
- If `version` omitted: Query latest version (highest `version_number`)
- To reconstruct full content: Start from version 1, apply all diffs sequentially

### Change History View

To show file change history:
1. Query all versions: `SELECT * FROM embeds WHERE file_path = '{path}' ORDER BY version_number`
2. For each version, display:
   - Version number and timestamp
   - Diff from previous version
   - Option to view full content at that point in time

### Storage Optimization

**Latest Version**:
- Stores full content in `encrypted_content`
- Stores diff in `encrypted_diff` (from previous version)

**Previous Versions**:
- Can store only diff (reconstruct from v1)
- Or store full content for faster access (trade-off: storage vs. speed)

**Recommendation**: Store full content for latest version, diffs only for previous versions. Reconstruct older versions on-demand when needed.

## Text Preview Optimization

For text-based embeds (code, documents, sheets), a lightweight `text_preview` field is always synced to the client for fast rendering, even when full content is stored separately.

### Text Preview Purpose

- **Fast Rendering**: Show preview immediately without loading full content
- **Storage Efficiency**: Full content can be loaded on-demand when device storage is constrained
- **Always Available**: Preview always synced, full content may be evicted from cache

### Implementation

**Text-Based Embeds**:
- `code`: First 12 lines of code
- `document`: First 200 words
- `sheet`: First 5 rows, 5 columns

**Storage**:
- `encrypted_text_preview`: Always synced to client (encrypted with same key as content)
- `encrypted_content`: Full content (may be evicted if storage constrained)

**Client-Side Behavior**:
1. **Render Preview**: Use `text_preview` for immediate display
2. **Full Content Available**: Show full content if loaded
3. **Full Content Missing**: Show preview + "Load full content" button
4. **On-Demand Loading**: Load full content from Directus when user requests

### Storage Constraint Handling

When device storage is constrained (IndexedDB quota):

1. **Priority**: Always keep `text_preview` (small, essential for rendering)
2. **Eviction**: Full content can be evicted from EmbedStore
3. **Rehydration**: Load full content on-demand from Directus when needed
4. **User Experience**: Preview always visible, full content loads when requested

### Benefits

- **Fast Initial Load**: Preview renders immediately
- **Reduced Storage**: Full content not always needed locally
- **Graceful Degradation**: Preview available even if full content evicted
- **On-Demand Loading**: Full content loaded only when needed

## Migration from Current Architecture

### Current State

- Messages contain TOON code blocks with skill results
- EmbedStore stores embed content client-side only
- No server-side embed storage

### Migration Steps

1. **Create Directus Schema**: Add `embeds` collection
2. **Update Message Parsing**: Detect and extract embeds from existing messages
3. **Create Embed Entries**: Extract embed content from TOON code blocks, create embed entries
4. **Update Message References**: Replace TOON code blocks with embed reference JSON
5. **Update Server Cache**: Add embed caching alongside message caching
6. **Update Frontend**: Update parsing to handle embed references

### Backward Compatibility

- Old messages with TOON code blocks still work
- Parser detects both formats (TOON code blocks and embed references)
- Gradually migrate old messages to new format

## Implementation Files

### Backend Implementation

- **Directus Schema**: `backend/core/directus/schemas/embeds.yml` (to be created)
- **Embed Service**: `backend/core/api/app/services/embed_service.py` (to be created)
- **Cache Integration**: `backend/core/api/app/services/cache_chat_mixin.py` (update)
- **WebSocket Handler**: `backend/core/api/app/routes/handlers/websocket_handlers/embed_update_handler.py` (to be created)
- **Cache Warming**: `backend/core/api/app/tasks/user_cache_tasks.py` (update to load embeds by hashed_chat_id during Phase 1/2/3)
- **Sync Architecture**: See [Sync Architecture](./sync.md) - embeds must be loaded alongside messages during cache warming

### Frontend

- **EmbedStore**: `frontend/packages/ui/src/services/embedStore.ts`
- **Message Parsing**: `frontend/packages/ui/src/message_parsing/parse_message.ts` (update)
- **Embed Resolution**: `frontend/packages/ui/src/services/embedResolver.ts` (to be created)
- **Auto-Conversion**: `frontend/packages/ui/src/message_parsing/embedAutoConverter.ts` (to be created)
- **Sync Service**: `frontend/packages/ui/src/services/phasedSyncService.ts` (update to handle embed sync alongside messages)

## Benefits

1. **Independent Updates**: Update embed content without modifying message
2. **Long-Running Tasks**: Handle background tasks with status updates
3. **Cross-Chat References**: Link embeds across chats
4. **Efficient Caching**: Cache embeds separately for fast AI context
5. **Cleaner Messages**: Messages contain references, not heavy content
6. **Zero-Knowledge**: Maintains zero-knowledge architecture
7. **Scalability**: Embeds stored once, referenced many times
8. **Independent Sharing**: Share embeds independently of chats with zero-knowledge security
9. **File Versioning**: Efficient storage of file changes using diffs, reference files at specific points in time
10. **Storage Optimization**: Text previews always synced, full content loaded on-demand when storage is constrained
11. **Change History**: View how files evolved over time with automatic diff generation
12. **Duplicate Detection**: Prevent re-upload of identical files/code using content hash (storage cost savings)
13. **Composite Results**: Parent `app_skill_use` embeds contain `embed_ids` array pointing to child embeds (website, place, event)
14. **Minimal References**: Message references contain only type and embed_id - all details stored in embed entry
15. **Type Differentiation**: Clear separation between app_skill_use, website, place, event, file, code, sheet, document types

