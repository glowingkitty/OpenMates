# Embeds Architecture

> Embeds are separate entities from messages, stored independently and referenced in messages via lightweight JSON/YAML blocks. This enables independent updates, cross-chat references, and efficient handling of long-running tasks. All sensitive fields (type, chat_id, message_id, task_id) are protected client-side before storage to maintain zero-knowledge architecture.

## Overview

Embeds replace the previous "contents" model and represent a first-class entity for storing structured content separately from messages. This architecture enables:

- **Independent Updates**: Update embed content without modifying the message (e.g., long-running tasks)
- **Cross-Chat References**: Link/mention embeds across different chats
- **Efficient Caching**: Server can cache embeds separately from messages for fast AI context building
- **Cleaner Messages**: Messages contain lightweight references instead of heavy embedded content
- **Zero-Knowledge**: Embeds are client-encrypted before storage, maintaining zero-knowledge architecture

## Architecture Principles

### Separation of Concerns

- **Messages**: Store markdown text with lightweight embed references
- **Embeds**: Store full structured content (skill results, code blocks, files, sheets, etc.)
- **References**: Messages reference embeds via JSON/YAML blocks in markdown

### Zero-Knowledge Architecture

- Embeds are encrypted client-side using embed-specific encryption keys (independent of chats)
- Server stores only `encrypted_content` (cannot decrypt)
- **Privacy Protection**: `chat_id`, `message_id`, `task_id` are hashed client-side (SHA256) before sending to server - one-way hashing prevents server from linking embeds to chats/messages
- **Type Privacy**: `type` is encrypted client-side - server cannot determine embed type without decryption key
- Server cache uses vault encryption for AI processing (server can decrypt for context)
- Permanent storage in Directus is zero-knowledge (client-encrypted)
- **Independent Sharing**: Embeds can be shared independently of chats using shared encryption keys (stored in URL fragments, never sent to server)

### Dual Storage

- **Client-side**: ContentStore (IndexedDB) for fast local access and rendering
- **Server-side**: Directus for permanent storage and cross-device sync
- **Server Cache**: Redis cache for last 3 chats' embeds (vault-encrypted for AI context)

## Embed Model Structure

### Directus Schema (Permanent Storage)

```yaml
# Directus schema for embeds collection
embeds:
  type: collection
  fields:
    id:
      type: uuid
      note: "Primary Key - Unique identifier for the embed, auto-generated by Directus."
    
    embed_id:
      type: string
      note: "[Indexed] Unique identifier for the embed. Format: UUID v4. Generated by the client."
      options:
        unique: true
    
    hashed_chat_id:
      type: string
      note: "[Indexed] SHA256 hash of chat_id (for linking without exposing actual chat_id, protects privacy). Client-side hashed before sending to server."
    
    hashed_message_id:
      type: string
      note: "[Indexed] SHA256 hash of message_id (for linking without exposing actual message_id, protects privacy). Client-side hashed before sending to server. Can be null if referenced by multiple messages."
    
    hashed_task_id:
      type: string
      note: "[Optional] SHA256 hash of task_id (for long-running tasks, protects privacy). Used to update embed when task completes. Client-side hashed before sending to server."
    
    encrypted_type:
      type: string
      note: "[Encrypted] Type of embed encrypted client-side (app_skill_use, website, place, event, code, file, sheet, document, etc.). Server cannot determine embed type without decryption key. Encrypted with same key as encrypted_content."
    
    status:
      type: string
      note: "Status of embed: 'processing' | 'finished' | 'error'"
    
    hashed_user_id:
      type: string
      note: "[Indexed] Hashed user ID of embed owner"
    
    encryption_key_embed:
      type: string
      note: "[Encrypted] Embed-specific encryption key, encrypted with user's master key. Allows sharing independent of chat."
    
    share_mode:
      type: string
      note: "[Indexed] Sharing mode: 'private' | 'shared_with_user' | 'public'. Default: 'private'"
      default: "private"
    
    shared_with_users:
      type: json
      note: "[Optional] Array of hashed_user_ids who have access (for user-specific sharing)"
    
    embed_ids:
      type: json
      note: "[Optional] Array of embed IDs for composite app_skill_use embeds (e.g., web search contains embed_ids pointing to website embeds). Null for single embeds or non-app_skill_use embeds."
    
    encrypted_content:
      type: textfield
      note: "[Encrypted] Full embed content (TOON/JSON format). For app_skill_use embeds with composite results, contains query, provider, skill name, and metadata. For single embeds (code, file, sheet, document, website, place, event), contains the actual content. Encrypted with encryption_key_embed (private) or shared_encryption_key (shared)"
    
    encrypted_text_preview:
      type: textfield
      note: "[Encrypted] Lightweight text preview for text-based embeds (code, documents). Always synced to client for fast rendering. Encrypted with same key as encrypted_content."
    
    parent_embed_id:
      type: string
      note: "[Optional] For versioned embeds: references the parent embed_id this version is based on"
    
    version_number:
      type: integer
      note: "[Optional] Version number for this embed (starts at 1, increments on updates)"
    
    encrypted_diff:
      type: textfield
      note: "[Encrypted] For file updates: stores diff/patch between versions (unified diff format). Encrypted with same key as encrypted_content."
    
    file_path:
      type: string
      note: "[Optional] For code/file embeds: relative file path for detecting updates to same file"
    
    content_hash:
      type: string
      note: "[Indexed] SHA256 hash of embed content. Used for duplicate detection (file, code, sheet, document) and change detection (versioning). Not used for website, place, event, or app_skill_use embeds."
    
    created_at:
      type: integer
      note: "Unix timestamp (seconds) when the embed was created. Provided by the application."
    
    updated_at:
      type: integer
      note: "Unix timestamp (seconds) when the embed was last updated. Used for task completion updates and versioning."
```

### Client-Side ContentStore (IndexedDB)

Embeds are also stored in the client-side ContentStore for fast local access:

```typescript
interface EmbedStoreEntry {
  embed_id: string;
  type: EmbedType; // Decrypted type (client-side only, never sent to server)
  status: 'processing' | 'finished' | 'error';
  content: any; // Decrypted content (TOON/JSON)
  text_preview?: string; // Lightweight text preview (always synced, for text-based embeds)
  task_id?: string; // Plaintext task_id (client-side only, hashed before sending to server)
  chat_id?: string; // Plaintext chat_id (client-side only, hashed before sending to server)
  message_id?: string; // Plaintext message_id (client-side only, hashed before sending to server)
  parent_embed_id?: string; // For versioned embeds
  version_number?: number;
  diff?: string; // Unified diff for file updates
  file_path?: string; // For detecting file updates
  content_hash?: string; // SHA256 hash for deduplication
  share_mode: 'private' | 'shared_with_user' | 'public';
  createdAt: number;
  updatedAt: number;
}
```

### Server-Side Cache (Redis)

Embeds are cached server-side for fast AI context building:

- **Cache Key**: `embed:{embed_id}` (global cache, one entry per embed regardless of how many chats reference it)
- **Encryption**: Vault-encrypted with `encryption_key_user_server` (server can decrypt for AI)
- **TTL**: 24 hours (same as message cache)
- **Purpose**: Fast embed resolution when building AI context from cached chat history
- **Chat Index**: `chat:{chat_id}:embed_ids` (Redis Set tracking which embed_ids belong to each chat, used for eviction)
- **Access Control**: When loading from cache, verify `hashed_user_id` matches requesting user (for private embeds) or check `share_mode` and `shared_with_users` (for shared embeds)

## Embed Reference Format in Messages

Embeds are referenced in messages (both user and assistant) via JSON code blocks in markdown:

### Format

**Basic Reference** (all details stored in embed entry):
```json
{
  "type": "app_skill_use",
  "embed_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Versioned Reference** (for referencing files at specific points in time):
```json
{
  "type": "code",
  "embed_id": "550e8400-e29b-41d4-a716-446655440000",
  "version": 3
}
```

If `version` is omitted, references the latest version.

**Key Principle**: Message references are minimal - only `type` and `embed_id`. All content (title, description, query, results, metadata) is stored in the embed entry itself.

### Embed Types

**App Skill Executions**:
- **`app_skill_use`**: App skill execution results (e.g., web search, places search, events search, code generation, image generation). For composite results (web search, places, events), contains query, provider, metadata, and `embed_ids` array pointing to child embeds.

**Result Embeds** (child embeds for composite app skill results):
- **`website`**: Individual website from web search results (one embed per website)
- **`place`**: Individual place from location search (one embed per place)
- **`event`**: Individual event from event search (one embed per event)

**Content Embeds** (supports duplicate detection):
- **`file`**: Uploaded files (images, documents, etc.)
- **`code`**: Code blocks generated by LLM or pasted by user
- **`sheet`**: Tables/spreadsheets generated by LLM or pasted by user
- **`document`**: Rich text documents

### Composite Embeds Structure

Some app skills return multiple results. The structure uses a parent `app_skill_use` embed entry that contains metadata and references to child embed entries:

**Web Search Example**:
- Message reference (minimal):
  ```json
  {
    "type": "app_skill_use",
    "embed_id": "550e8400-e29b-41d4-a716-446655440000"
  }
  ```
- Parent embed entry (`embed_id: 550e8400...`, type: `app_skill_use`):
  - `encrypted_content`: Contains query, provider, skill name, and other search metadata
  - `embed_ids`: Array of embed IDs pointing to individual website embeds
    - `["660e8400-...", "770e8400-...", "880e8400-..."]`
- Child embed entries (individual websites):
  - Each has `type: "website"`
  - Contains website-specific content (title, URL, description, snippets, etc.)

**Places/Events Search**: Same structure - parent `app_skill_use` embed contains query/metadata and `embed_ids` array pointing to individual `place`/`event` embeds.

**Single Result Skills** (e.g., code generation, image generation):
- Message reference:
  ```json
  {
    "type": "app_skill_use",
    "embed_id": "550e8400-e29b-41d4-a716-446655440000"
  }
  ```
- Embed entry (type: `app_skill_use`):
  - `encrypted_content`: Contains skill result (code, image metadata, etc.)
  - `embed_ids`: null (single result, no child embeds)

### Example in Message Markdown

```markdown
I found some information about egg prices:

```json
{
  "type": "app_skill_use",
  "embed_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

The search results show that egg prices have increased significantly since 2023.
```

The embed entry (`embed_id: 550e8400...`, type: `app_skill_use`) contains:
- `encrypted_content`: Query, provider, skill name, and other search metadata
- `embed_ids`: `["660e8400-...", "770e8400-...", "880e8400-..."]` (array of website embed IDs)

Each website embed (referenced in `embed_ids`, type: `website`) contains:
- `encrypted_content`: Title, URL, description, snippets, etc.

## Embed Lifecycle

### 1. Creation

**App Skill Execution**:
1. Skill executes and returns results
2. **For composite results** (web search, places, events):
   - Create child embed entries (one per result): `website`, `place`, or `event` embeds
   - Create parent embed entry: `app_skill_use` embed
   - Parent embed contains: query, provider, skill name, metadata, and `embed_ids` array pointing to child embeds
   - Message references only the parent embed (minimal: `type: "app_skill_use"` + `embed_id`)
3. **For single results** (code generation, image generation):
   - Create single `app_skill_use` embed entry
   - Check for duplicates using `content_hash` (if applicable)
   - `embed_ids`: null (no child embeds)
4. **Client-Side Privacy Protection**:
   - Hash `chat_id`, `message_id`, `task_id` using SHA256 (one-way, protects privacy)
   - Encrypt `type` with same key as `encrypted_content` (server cannot determine embed type)
   - TOON-encode and encrypt embed content client-side
5. Embed is stored in ContentStore (IndexedDB) and sent to server
6. Server stores embed in Directus (encrypted, with hashed IDs and encrypted type)
7. Message references embed via minimal JSON block (`type` + `embed_id` only)

**Long-Running Tasks**:
1. Skill execution starts, returns `task_id` immediately
2. Client creates embed with `status: "processing"` and `task_id`
3. LLM sees embed reference and responds: "I started the task, I'll update you when ready"
4. When task completes, WebSocket event with `task_id` triggers embed update
5. Client updates embed content, changes `status: "finished"`
6. Frontend automatically updates embed preview

### 2. Update

**Task Completion**:
- WebSocket event: `embed_update` with `task_id` (hashed) and new content
- Client hashes `task_id` and queries embed by `hashed_task_id`
- Client updates embed in ContentStore
- Client sends updated embed to server (encrypted, with hashed IDs)
- Server updates embed in Directus (using hashed_task_id for lookup)
- Server updates embed in cache: `embed:{embed_id}` (global cache, available to all chats that reference it)
- Frontend re-renders embed preview automatically

### 3. Resolution (Rendering)

**Client-Side Rendering**:
1. Parse message markdown
2. Detect embed reference JSON blocks
3. Load embed from ContentStore (IndexedDB)
4. If missing, fetch from Directus (decrypt client-side)
   - Decrypt `encrypted_type` to determine embed type
   - Decrypt `encrypted_content` to get embed content
5. Render embed preview based on decrypted type

**Server-Side Context Building**:
1. Parse message markdown from cache
2. Detect embed reference JSON blocks
3. Load embeds from cache (`embed:{embed_id}` for each embed_id, verify access control)
4. Replace embed references with actual content (TOON format)
5. Include in AI context for processing

## Auto-Conversion of LLM-Generated Content

### Decision: Client-Side Conversion

**Question**: Should we auto-convert LLM-generated code blocks and tables to embeds?

**Answer**: Yes, but with important considerations:

### Implementation Approach

**When to Convert**:
- **Code blocks**: Always convert (reduces message size, enables independent updates)
- **Sheets/Tables**: Always convert (sheets can be large, benefit from embed structure)
- **App skill results**: Already embeds (no conversion needed)

**Where to Convert**:
- **Client-side**: Parse assistant response markdown, detect code blocks/sheets
- **Before encryption**: Convert to embeds, create embed entries
- **Replace in message**: Replace code block/sheet content with embed reference JSON

**Server Cache Consideration**:
- Server cache stores messages with embed references (not full content)
- When building AI context, server resolves embeds from cache (`embed:{embed_id}`)
- If embed missing from cache, server requests from client (fallback)
- This ensures server cache remains efficient while supporting auto-conversion

### Conversion Flow

1. **Assistant Response Received**:
   - Client receives markdown response from server
   - Parse markdown to detect code blocks and sheets
   - For each code block/sheet:
     - Generate `embed_id` (UUID)
     - Create embed entry in ContentStore
     - Encrypt embed content
     - Send embed to server for Directus storage
     - Replace code block/sheet in markdown with embed reference JSON

2. **Message Storage**:
   - Store message with embed references (not full content)
   - Message is smaller and cleaner
   - Embeds stored separately

3. **Rendering**:
   - Parse message markdown
   - Detect embed references
   - Load embeds from ContentStore
   - Render embed previews

## Embed Resolution for AI Context

### Server-Side Resolution

When building AI context from cached chat history, the server must resolve embed references:

1. **Parse Message Markdown**:
   - Extract embed reference JSON blocks
   - Identify `embed_id` values

2. **Load Embeds from Cache**:
   - Check `embed:{embed_id}` cache for each embed_id
   - Verify access control (check `hashed_user_id` for private embeds, or `share_mode`/`shared_with_users` for shared embeds)
   - Load embeds by `embed_id`
   - Decrypt using vault key (server can decrypt)

3. **Replace References with Content**:
   - Replace embed reference JSON blocks with actual embed content (TOON format)
   - Include in message history for AI processing

4. **Fallback if Missing**:
   - If embed not in cache, request from client
   - Client loads from Directus, decrypts, sends to server
   - Server caches embed for future use

### Client-Side Resolution (Older Chats)

For chats not in server cache (older than last 3):

1. **Client Loads Chat**:
   - Load messages from Directus (encrypted)
   - Decrypt messages client-side

2. **Parse and Resolve**:
   - Parse message markdown
   - Detect embed references
   - Load embeds from Directus (encrypted)
   - Decrypt embeds client-side
   - Render embed previews

3. **Send to Server**:
   - When user sends follow-up message
   - Client sends decrypted message history with resolved embeds
   - Server caches for future use

## Long-Running Tasks

### Problem

Some app skills take seconds or minutes to complete (e.g., image generation, video processing, web scraping). The LLM needs to respond immediately while the task runs in the background.

### Solution

1. **Immediate Response**:
   - Skill execution starts, returns `task_id`
   - Client creates embed with `status: "processing"` and `task_id`
   - Message references embed immediately
   - LLM sees embed reference and responds: "I started the task, I'll let you know when it's ready"

2. **Task Completion**:
   - Task completes, WebSocket event sent: `embed_update`
   - Event includes `hashed_task_id` (SHA256 hash) and completed embed content
   - Client hashes `task_id` and queries embed by `hashed_task_id`
   - Client updates embed: `status: "finished"`, new content
   - Client sends updated embed to server (encrypted, with hashed IDs)
   - Server updates embed in Directus (using hashed_task_id for lookup)
   - Frontend automatically updates embed preview
   - User sees updated results without new message

### WebSocket Event Format

```json
{
  "event": "embed_update",
  "payload": {
    "hashed_task_id": "a1b2c3d4...", // SHA256 hash of task_id (privacy protection)
    "embed_id": "550e8400-e29b-41d4-a716-446655440000",
    "status": "finished",
    "encrypted_content": "...", // Client-encrypted embed content
    "hashed_chat_id": "e5f6g7h8...", // SHA256 hash of chat_id (privacy protection)
    "hashed_message_id": "i9j0k1l2..." // SHA256 hash of message_id (privacy protection)
  }
}
```

## Cross-Chat References

Embeds can be referenced in multiple messages or even different chats:

### Use Cases

- **Copy/Paste**: User copies an embed from one chat to another
- **Mention**: User references a previous search result in a new chat
- **Link**: User shares an embed with another user (future feature)

### Implementation

- Embed `chat_id` points to the chat where it was created (can be null for shared embeds)
- Embed can be referenced in any message (same or different chat)
- Frontend resolves embed from ContentStore or Directus
- Server cache includes embeds for all referenced chats (if in last 3)
- **Same User Cross-Chat**: Uses `encryption_key_embed` (decrypted from master key) - no re-encryption needed

## Independent Embed Sharing

Embeds can be shared independently of chats, following the same zero-knowledge architecture as chat sharing. See [Share Chat Architecture](./share_chat.md) for the underlying principles.

### Sharing Modes

**Private** (default):
- Encrypted with `encryption_key_embed` (derived from user's master key)
- Only accessible in original chat context
- Cross-chat references within same user work seamlessly

**Shared with User**:
- Re-encrypted with `shared_encryption_key` (generated client-side)
- Access tied to recipient's account
- Recipient receives notification with secure link

**Public**:
- Re-encrypted with `shared_encryption_key` (generated client-side)
- Anyone with link can access (no user verification)
- Key stored in URL fragment (never sent to server)

### Sharing Flow

**Access Flow** (when someone opens a shared embed link):
1. Client extracts `embed_id` and `key` from URL fragment: `/#embed-id={embed_id}&key={shared_encryption_key}`
2. Client sends request to server with `embed_id` (key stays in fragment, never sent to server)
3. Server checks:
   - Does embed exist?
   - If `share_mode === 'public'`: Return encrypted content
   - If `share_mode === 'shared_with_user'`: Check if user's `hashed_user_id` is in `shared_with_users` array
     - If yes: Return encrypted content
     - If no: Return error
   - If `share_mode === 'private'`: Return error
4. If access granted: Server returns encrypted content
5. Client decrypts content using `shared_encryption_key` from URL fragment
6. If access denied or embed doesn't exist: Show unified error message: "Embed can't be found. Either it doesn't exist or you don't have access to it."

**Share with User**:
1. User clicks "Share embed" on embed preview
2. Client generates `shared_encryption_key` (random, client-side)
3. Client re-encrypts embed content with shared key
4. Client sends encrypted embed + recipient's `hashed_user_id` to server
5. Server stores encrypted embed with `share_mode: 'shared_with_user'` and adds recipient to `shared_with_users` array
6. Server sends notification to recipient with link: `/#embed-id={embed_id}&key={shared_encryption_key}`
7. Recipient's client decrypts using key from URL fragment

**Share Publicly**:
1. Similar flow, but `share_mode: 'public'`
2. Link format: `/#embed-id={embed_id}&key={shared_encryption_key}`
3. Anyone with link can access (no user verification needed)
4. Key stored in URL fragment (never sent to server)

**Cross-Chat Reference (Same User)**:
1. User references embed in different chat
2. Client uses `encryption_key_embed` (decrypted from master key)
3. No re-encryption needed (same user, same key)
4. Embed accessible across all user's chats

### Security Properties

**Zero-Knowledge Maintained**:
- Server never sees `shared_encryption_key` (URL fragment only)
- Server stores only encrypted content
- Client-side encryption/decryption only

**Access Control**:
- Private: Only accessible in original chat
- Shared with user: Access tied to recipient's account
- Public: Anyone with link (like chat sharing)

**Key Management**:
- `encryption_key_embed`: Encrypted with user's master key, stored in Directus
- `shared_encryption_key`: Generated client-side, stored in URL fragment only
- Server never has decryption capability

### URL Fragment Pattern

Follows chat sharing pattern: `/#embed-id={embed_id}&key={shared_encryption_key}`
- Key never sent to server (fragment only)
- Client stores key after first access (removes from URL)
- Server checks `share_mode` and `shared_with_users` for access control
- No key verification needed - wrong key simply can't decrypt content

## File Versioning and Diff Storage

Embeds support efficient versioning for files (code, documents, sheets) by storing only diffs between versions, enabling:
- **Efficient Storage**: Only changes stored, not full content for each version
- **Time-Based References**: Reference files at specific points in time
- **Change History**: View how files evolved over time
- **Automatic Detection**: Auto-detect when same file is updated

### Version Structure

Each version is a separate embed entry with:
- `parent_embed_id`: References the previous version (null for version 1)
- `version_number`: Sequential version number (starts at 1)
- `file_path`: Relative file path for detecting updates to same file
- `encrypted_diff`: Unified diff format string (from parent to this version)
- `content_hash`: SHA256 hash of full content for deduplication

### Diff Storage Format

**Recommendation**: Single string (unified diff format) per version entry.

**Why Single String?**:
- Each embed entry = one version, so one diff per entry fits naturally
- Efficient storage: only changes stored, no duplication
- Simple queries: get version N by `embed_id` + `version_number`
- Chain reconstruction: start from v1, apply diffs sequentially
- Standard format: unified diff is widely supported

**Example Structure**:
```
Version 1 (embed_id: abc123): 
  - full content stored
  - no diff (original version)
  - version_number: 1
  - parent_embed_id: null

Version 2 (embed_id: def456): 
  - diff from v1→v2 (unified diff string)
  - version_number: 2
  - parent_embed_id: abc123

Version 3 (embed_id: ghi789): 
  - diff from v2→v3 (unified diff string)
  - version_number: 3
  - parent_embed_id: def456
```

### File Update Detection

When LLM generates or updates a code file:

1. **Detect Existing File**:
   - Check if embed with same `file_path` exists
   - Query: `SELECT * FROM embeds WHERE file_path = '{path}' AND hashed_user_id = '{user_id}' ORDER BY version_number DESC LIMIT 1`

2. **Compare Content**:
   - Calculate `content_hash` of new content
   - Compare with existing version's `content_hash`
   - If different: create new version

3. **Generate Diff**:
   - Compute unified diff from previous version to new version
   - Store diff in `encrypted_diff` field
   - Store full content in `encrypted_content` (for latest version)

4. **Create New Version**:
   - Generate new `embed_id` (UUID)
   - Set `parent_embed_id` to previous version's `embed_id`
   - Increment `version_number`
   - Store diff and metadata

### Referencing Files at Specific Points in Time

Messages can reference specific versions:

```json
{
  "type": "code",
  "embed_id": "550e8400-e29b-41d4-a716-446655440000",
  "version": 3
}
```

**Resolution**:
- If `version` specified: Query embed with `embed_id` + `version_number`
- If `version` omitted: Query latest version (highest `version_number`)
- To reconstruct full content: Start from version 1, apply all diffs sequentially

### Change History View

To show file change history:
1. Query all versions: `SELECT * FROM embeds WHERE file_path = '{path}' ORDER BY version_number`
2. For each version, display:
   - Version number and timestamp
   - Diff from previous version
   - Option to view full content at that point in time

### Storage Optimization

**Latest Version**:
- Stores full content in `encrypted_content`
- Stores diff in `encrypted_diff` (from previous version)

**Previous Versions**:
- Can store only diff (reconstruct from v1)
- Or store full content for faster access (trade-off: storage vs. speed)

**Recommendation**: Store full content for latest version, diffs only for previous versions. Reconstruct older versions on-demand when needed.

## Text Preview Optimization

For text-based embeds (code, documents, sheets), a lightweight `text_preview` field is always synced to the client for fast rendering, even when full content is stored separately.

### Text Preview Purpose

- **Fast Rendering**: Show preview immediately without loading full content
- **Storage Efficiency**: Full content can be loaded on-demand when device storage is constrained
- **Always Available**: Preview always synced, full content may be evicted from cache

### Implementation

**Text-Based Embeds**:
- `code`: First 12 lines of code
- `document`: First 200 words
- `sheet`: First 5 rows, 5 columns

**Storage**:
- `encrypted_text_preview`: Always synced to client (encrypted with same key as content)
- `encrypted_content`: Full content (may be evicted if storage constrained)

**Client-Side Behavior**:
1. **Render Preview**: Use `text_preview` for immediate display
2. **Full Content Available**: Show full content if loaded
3. **Full Content Missing**: Show preview + "Load full content" button
4. **On-Demand Loading**: Load full content from Directus when user requests

### Storage Constraint Handling

When device storage is constrained (IndexedDB quota):

1. **Priority**: Always keep `text_preview` (small, essential for rendering)
2. **Eviction**: Full content can be evicted from ContentStore
3. **Rehydration**: Load full content on-demand from Directus when needed
4. **User Experience**: Preview always visible, full content loads when requested

### Benefits

- **Fast Initial Load**: Preview renders immediately
- **Reduced Storage**: Full content not always needed locally
- **Graceful Degradation**: Preview available even if full content evicted
- **On-Demand Loading**: Full content loaded only when needed

## Migration from Current Architecture

### Current State

- Messages contain TOON code blocks with skill results
- ContentStore stores embed content client-side only
- No server-side embed storage

### Migration Steps

1. **Create Directus Schema**: Add `embeds` collection
2. **Update Message Parsing**: Detect and extract embeds from existing messages
3. **Create Embed Entries**: Extract embed content from TOON code blocks, create embed entries
4. **Update Message References**: Replace TOON code blocks with embed reference JSON
5. **Update Server Cache**: Add embed caching alongside message caching
6. **Update Frontend**: Update parsing to handle embed references

### Backward Compatibility

- Old messages with TOON code blocks still work
- Parser detects both formats (TOON code blocks and embed references)
- Gradually migrate old messages to new format

## Implementation Files

### Backend Implementation

- **Directus Schema**: `backend/core/directus/schemas/embeds.yml` (to be created)
- **Embed Service**: `backend/core/api/app/services/embed_service.py` (to be created)
- **Cache Integration**: `backend/core/api/app/services/cache_chat_mixin.py` (update)
- **WebSocket Handler**: `backend/core/api/app/routes/handlers/websocket_handlers/embed_update_handler.py` (to be created)
- **Cache Warming**: `backend/core/api/app/tasks/user_cache_tasks.py` (update to load embeds by hashed_chat_id during Phase 1/2/3)
- **Sync Architecture**: See [Sync Architecture](./sync.md) - embeds must be loaded alongside messages during cache warming

### Frontend

- **ContentStore**: `frontend/packages/ui/src/services/contentStore.ts` (update)
- **Message Parsing**: `frontend/packages/ui/src/message_parsing/parse_message.ts` (update)
- **Embed Resolution**: `frontend/packages/ui/src/services/embedResolver.ts` (to be created)
- **Auto-Conversion**: `frontend/packages/ui/src/message_parsing/embedAutoConverter.ts` (to be created)
- **Sync Service**: `frontend/packages/ui/src/services/phasedSyncService.ts` (update to handle embed sync alongside messages)

## Benefits

1. **Independent Updates**: Update embed content without modifying message
2. **Long-Running Tasks**: Handle background tasks with status updates
3. **Cross-Chat References**: Link embeds across chats
4. **Efficient Caching**: Cache embeds separately for fast AI context
5. **Cleaner Messages**: Messages contain references, not heavy content
6. **Zero-Knowledge**: Maintains zero-knowledge architecture
7. **Scalability**: Embeds stored once, referenced many times
8. **Independent Sharing**: Share embeds independently of chats with zero-knowledge security
9. **File Versioning**: Efficient storage of file changes using diffs, reference files at specific points in time
10. **Storage Optimization**: Text previews always synced, full content loaded on-demand when storage is constrained
11. **Change History**: View how files evolved over time with automatic diff generation
12. **Duplicate Detection**: Prevent re-upload of identical files/code using content hash (storage cost savings)
13. **Composite Results**: Parent `app_skill_use` embeds contain `embed_ids` array pointing to child embeds (website, place, event)
14. **Minimal References**: Message references contain only type and embed_id - all details stored in embed entry
15. **Type Differentiation**: Clear separation between app_skill_use, website, place, event, file, code, sheet, document types

